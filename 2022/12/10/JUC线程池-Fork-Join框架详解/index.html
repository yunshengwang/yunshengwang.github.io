<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>JUC线程池_Fork_Join框架详解 | Mr.Wang Blog</title>
  <meta name="keywords" content=" java , 多线程 ">
  <meta name="description" content="JUC线程池_Fork_Join框架详解 | Mr.Wang Blog">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="目录   问题引入 解决方案 方式一： 硬核捕获 方式二： 动态代理 JDK 动态代理 spring 注入代理 工具类 CGlib 动态代理   方式三：Spring Aop实现 方式四：Spring 自带重试工具 方式五：Gavua 重试用法   总结  问题引入 现有一个接口，调用4次后才可已返回正常结果  12345678910111213141516171819public class R">
<meta property="og:type" content="article">
<meta property="og:title" content="Java接口重试的几种实现">
<meta property="og:url" content="http://example.com/2023/01/23/Java%E6%8E%A5%E5%8F%A3%E9%87%8D%E8%AF%95%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="Mr.Wang Blog">
<meta property="og:description" content="目录   问题引入 解决方案 方式一： 硬核捕获 方式二： 动态代理 JDK 动态代理 spring 注入代理 工具类 CGlib 动态代理   方式三：Spring Aop实现 方式四：Spring 自带重试工具 方式五：Gavua 重试用法   总结  问题引入 现有一个接口，调用4次后才可已返回正常结果  12345678910111213141516171819public class R">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-01-23T05:36:59.000Z">
<meta property="article:modified_time" content="2023-01-23T05:43:26.823Z">
<meta property="article:author" content="王云生">
<meta property="article:tag" content="java">
<meta property="article:tag" content="retry">
<meta name="twitter:card" content="summary">


<link rel="icon" href="/img/avatar.jpg">

<link href="/css/style.css?v=1.1.0" rel="stylesheet">

<link href="/css/hl_theme/atom-light.css?v=1.1.0" rel="stylesheet">

<link href="//cdn.jsdelivr.net/npm/animate.css@4.1.0/animate.min.css" rel="stylesheet">

<script src="//cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js"></script>
<script src="/js/titleTip.js?v=1.1.0" ></script>

<script src="//cdn.jsdelivr.net/npm/highlightjs@9.16.2/highlight.pack.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>

<script src="//cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js"></script>



<script src="//cdn.jsdelivr.net/npm/jquery.cookie@1.4.1/jquery.cookie.min.js" ></script>

<script src="/js/iconfont.js?v=1.1.0" ></script>

<meta name="generator" content="Hexo 6.3.0"></head>
<div style="display: none">
  <input class="theme_disqus_on" value="false">
  <input class="theme_preload_comment" value="">
  <input class="theme_blog_path" value="">
  <input id="theme_shortcut" value="true" />
  <input id="theme_highlight_on" value="true" />
  <input id="theme_code_copy" value="true" />
</div>



<body>
<aside class="nav">
    <div class="nav-left">
        <a href="/"
   class="avatar_target">
    <img class="avatar"
         src="/img/avatar.jpg"/>
</a>
<div class="author">
    <span>王云生</span>
</div>

<div class="icon">
    
        
            <a title="cnblogs"
               href="https://home.cnblogs.com/"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-cnblogs"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="jianshu"
               href="https://www.jianshu.com/u/a996358a335f"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-jianshu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="zhihu"
               href="https://www.zhihu.com/people/yun-sheng-10-62-26"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-zhihu"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="csdn"
               href="https://blog.csdn.net/u011593571?type=collect"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-csdn"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="oschina"
               href="https://my.oschina.net/u/4978723"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-oschina"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="juejin"
               href="https://juejin.cn/user/2604099346111086"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-juejin"></use>
                    </svg>
                
            </a>
        
    
        
            <a title="email"
               href="mailto:w_huilong@163.com"
               target="_blank">
                
                    <svg class="iconfont-svg" aria-hidden="true">
                        <use xlink:href="#icon-email"></use>
                    </svg>
                
            </a>
        
    
</div>




<ul>
    <li>
        <div class="all active" data-rel="全部文章">全部文章
            
                <small>(69)</small>
            
        </div>
    </li>
    
        
            
                <li>
                    <div data-rel="导读">
                        
                        导读
                        <small>(1)</small>
                        
                    </div>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="JAVA">
                        <i class="fold iconfont icon-right"></i>
                        
                        JAVA
                        <small>(64)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="JAVA<--->JAVA8特性">
                                        
                                        JAVA8特性
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="JAVA<--->JAVA8以上版本特性">
                                        
                                        JAVA8以上版本特性
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="JAVA<--->JAVA多线程">
                                        
                                        JAVA多线程
                                        
                                            <small>(27
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="JAVA<--->JAVA基础">
                                        
                                        JAVA基础
                                        
                                            <small>(8
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="JAVA<--->Java集合框架">
                                        
                                        Java集合框架
                                        
                                            <small>(9
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="JAVA<--->Java其他相关">
                                        
                                        Java其他相关
                                        
                                            <small>(2
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="JAVA<--->Java重用技能">
                                        
                                        Java重用技能
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="JAVA<--->JAVAIO">
                                        
                                        JAVAIO
                                        
                                            <small>(13
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="JAVA<--->JVM相关">
                                        
                                        JVM相关
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="Spring">
                        <i class="fold iconfont icon-right"></i>
                        
                        Spring
                        <small>(2)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="Spring<--->SpringBoot2.5.X系列">
                                        
                                        SpringBoot2.5.X系列
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="Spring<--->SpringFrameWork5基础">
                                        
                                        SpringFrameWork5基础
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
                <li>
                    <div data-rel="工具">
                        <i class="fold iconfont icon-right"></i>
                        
                        工具
                        <small>(2)</small>
                        
                    </div>
                    
                        <ul class="sub hide">
                            
                                <li>
                                    <div data-rel="工具<--->百宝箱">
                                        
                                        百宝箱
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                                <li>
                                    <div data-rel="工具<--->HEXO">
                                        
                                        HEXO
                                        
                                            <small>(1
                                                )</small>
                                        
                                    </div>
                                    
                                </li>
                            
                        </ul>
                    
                </li>
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
        
            
        
    
</ul>
<div class="left-bottom">
    <div class="menus">
        
            
            
            
    </div>
    <div>
        
        
    </div>
</div>
<input type="hidden" id="yelog_site_posts_number" value="69">
<input type="hidden" id="yelog_site_word_count" value="357k">
<div style="display: none">
    <span id="busuanzi_value_site_uv"></span>
    <span id="busuanzi_value_site_pv"></span>
</div>

    </div>
    <div class="nav-right">
        <div class="friends-area">
    <div class="friends-title">
        友情链接
        <i class="iconfont icon-left"></i>
    </div>
    <div class="friends-content">
        <ul>
            
            <li><a target="_blank" href="http://yelog.org/">叶落阁</a></li>
            
        </ul>
    </div>
</div>
        <div class="title-list">
    <div class="right-top">
        <div id="default-panel">
            <i class="iconfont icon-search" data-title="搜索 快捷键 i"></i>
            <div class="right-title">全部文章</div>
            <i class="iconfont icon-file-tree" data-title="切换到大纲视图 快捷键 w"></i>
        </div>
        <div id="search-panel">
            <i class="iconfont icon-left" data-title="返回"></i>
            <input id="local-search-input" autocomplete="off"/>
            <label class="border-line" for="input"></label>
            <i class="iconfont icon-case-sensitive" data-title="大小写敏感"></i>
            <i class="iconfont icon-tag" data-title="标签"></i>
        </div>
        <div id="outline-panel" style="display: none">
            <div class="right-title">大纲</div>
            <i class="iconfont icon-list" data-title="切换到文章列表"></i>
        </div>
    </div>

    <div class="tags-list">
    <input id="tag-search" />
    <div class="tag-wrapper">
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>多线程</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>aio</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>ArrayList</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>bio</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Collection</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>HashMap</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>HashSet</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>hexo</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>io</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>java</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>java8</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>java8+</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>jvm</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>LinkedHashSet</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>LinkedList</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Map</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>nio</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>PriorityQueue</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Queue</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>retry</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>spring</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>spring boot</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>Stack</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>tool</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>TreeMap</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>TreeSet</a>
            </li>
        
            <li class="article-tag-list-item">
                <i class="iconfont icon-tag"></i><a>WeakHashMap</a>
            </li>
        
    </div>

</div>

    
    <nav id="title-list-nav">
        
        
        <a id="top" class="全部文章 导读 "
           href="/2022/12/11/%E5%AF%BC%E8%AF%BB/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="导读">导读</span>
            <span class="post-date" title="2022-12-11 14:39:22">2022/12/11</span>
        </a>
        
        
        <a id="top" class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/Java%E5%B9%B6%E5%8F%91%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="Java并发知识体系详解">Java并发知识体系详解</span>
            <span class="post-date" title="2022-12-10 21:46:29">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA Java重用技能 "
           href="/2023/01/23/Java%E6%8E%A5%E5%8F%A3%E9%87%8D%E8%AF%95%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0/"
           data-tag="java,retry"
           data-author="" >
            <span class="post-title" title="Java接口重试的几种实现">Java接口重试的几种实现</span>
            <span class="post-date" title="2023-01-23 13:36:59">2023/01/23</span>
        </a>
        
        
        <a  class="全部文章 工具 百宝箱 "
           href="/2022/12/11/%E5%BC%80%E5%8F%91%E7%99%BE%E5%AE%9D%E7%AE%B1/"
           data-tag="tool"
           data-author="" >
            <span class="post-title" title="开发百宝箱">开发百宝箱</span>
            <span class="post-date" title="2022-12-11 14:35:47">2022/12/11</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA8特性 "
           href="/2022/12/11/Java8CompletableFuture%E7%94%A8%E6%B3%95%E5%85%A8%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="Java8CompletableFuture用法全解">Java8CompletableFuture用法全解</span>
            <span class="post-date" title="2022-12-11 13:31:35">2022/12/11</span>
        </a>
        
        
        <a  class="全部文章 JAVA Java其他相关 "
           href="/2022/12/10/Better-Java/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="Better_Java">Better_Java</span>
            <span class="post-date" title="2022-12-10 23:26:09">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA Java其他相关 "
           href="/2022/12/10/Awesome-Java/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="Awesome_Java">Awesome_Java</span>
            <span class="post-date" title="2022-12-10 23:24:55">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JVM相关 "
           href="/2022/12/10/JVM%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3/"
           data-tag="java,jvm"
           data-author="" >
            <span class="post-title" title="JVM相关知识体系详解">JVM相关知识体系详解</span>
            <span class="post-date" title="2022-12-10 23:23:42">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA8以上版本特性 "
           href="/2022/12/10/Java8%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC%E7%89%B9%E6%80%A7%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3/"
           data-tag="java,java8+"
           data-author="" >
            <span class="post-title" title="Java8以上版本特性知识体系详解">Java8以上版本特性知识体系详解</span>
            <span class="post-date" title="2022-12-10 23:22:38">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA8特性 "
           href="/2022/12/10/Java8%E7%89%B9%E6%80%A7%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3/"
           data-tag="java,java8"
           data-author="" >
            <span class="post-title" title="Java8特性知识体系详解">Java8特性知识体系详解</span>
            <span class="post-date" title="2022-12-10 23:20:22">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVAIO "
           href="/2022/12/10/JavaNIO-%E9%9B%B6%E6%8B%B7%E8%B4%9D%E5%AE%9E%E7%8E%B0/"
           data-tag="java,io,nio"
           data-author="" >
            <span class="post-title" title="JavaNIO_零拷贝实现">JavaNIO_零拷贝实现</span>
            <span class="post-date" title="2022-12-10 23:17:49">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVAIO "
           href="/2022/12/10/JavaIO-Netty/"
           data-tag="java,io"
           data-author="" >
            <span class="post-title" title="JavaIO_Netty">JavaIO_Netty</span>
            <span class="post-date" title="2022-12-10 23:16:57">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVAIO "
           href="/2022/12/10/JavaAIO-%E5%BC%82%E6%AD%A5IO%E8%AF%A6%E8%A7%A3/"
           data-tag="java,io,aio"
           data-author="" >
            <span class="post-title" title="JavaAIO_异步IO详解">JavaAIO_异步IO详解</span>
            <span class="post-date" title="2022-12-10 23:15:50">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVAIO "
           href="/2022/12/10/JavaNIO-IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E8%AF%A6%E8%A7%A3/"
           data-tag="java,io,nio"
           data-author="" >
            <span class="post-title" title="JavaNIO_IO多路复用详解">JavaNIO_IO多路复用详解</span>
            <span class="post-date" title="2022-12-10 23:15:03">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVAIO "
           href="/2022/12/10/JavaNIO-%E5%9F%BA%E7%A1%80%E8%AF%A6%E8%A7%A3/"
           data-tag="java,io,nio"
           data-author="" >
            <span class="post-title" title="JavaNIO_基础详解">JavaNIO_基础详解</span>
            <span class="post-date" title="2022-12-10 23:13:53">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVAIO "
           href="/2022/12/10/JavaIO-BIO%E8%AF%A6%E8%A7%A3/"
           data-tag="java,io,bio"
           data-author="" >
            <span class="post-title" title="JavaIO_BIO详解">JavaIO_BIO详解</span>
            <span class="post-date" title="2022-12-10 23:13:00">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVAIO "
           href="/2022/12/10/IO%E6%A8%A1%E5%9E%8B-UnixIO%E6%A8%A1%E5%9E%8B/"
           data-tag="java,io"
           data-author="" >
            <span class="post-title" title="IO模型_UnixIO模型">IO模型_UnixIO模型</span>
            <span class="post-date" title="2022-12-10 23:11:48">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVAIO "
           href="/2022/12/10/%E5%B8%B8%E8%A7%81%E7%B1%BB%E4%BD%BF%E7%94%A8/"
           data-tag="java,io"
           data-author="" >
            <span class="post-title" title="常见类使用">常见类使用</span>
            <span class="post-date" title="2022-12-10 23:10:36">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVAIO "
           href="/2022/12/10/%E6%BA%90%E7%A0%81-OutputStream/"
           data-tag="java,io"
           data-author="" >
            <span class="post-title" title="源码_OutputStream">源码_OutputStream</span>
            <span class="post-date" title="2022-12-10 23:09:41">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVAIO "
           href="/2022/12/10/%E6%BA%90%E7%A0%81-InputStream/"
           data-tag="java,io"
           data-author="" >
            <span class="post-title" title="源码_InputStream">源码_InputStream</span>
            <span class="post-date" title="2022-12-10 23:08:23">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVAIO "
           href="/2022/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"
           data-tag="java,io"
           data-author="" >
            <span class="post-title" title="设计模式_装饰者模式">设计模式_装饰者模式</span>
            <span class="post-date" title="2022-12-10 23:06:57">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVAIO "
           href="/2022/12/10/%E5%88%86%E7%B1%BB-%E4%BC%A0%E8%BE%93-%E6%93%8D%E4%BD%9C/"
           data-tag="java,io"
           data-author="" >
            <span class="post-title" title="分类_传输_操作">分类_传输_操作</span>
            <span class="post-date" title="2022-12-10 23:06:13">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVAIO "
           href="/2022/12/10/Java-IO%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3/"
           data-tag="java,io"
           data-author="" >
            <span class="post-title" title="Java_IO知识体系详解">Java_IO知识体系详解</span>
            <span class="post-date" title="2022-12-10 23:04:43">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/ThreadLocal%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="ThreadLocal详解">ThreadLocal详解</span>
            <span class="post-date" title="2022-12-10 22:58:20">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/JUC%E5%B7%A5%E5%85%B7%E7%B1%BB-Exchanger%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="JUC工具类_Exchanger详解">JUC工具类_Exchanger详解</span>
            <span class="post-date" title="2022-12-10 22:57:34">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/JUC%E5%B7%A5%E5%85%B7%E7%B1%BB-Phaser%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="JUC工具类_Phaser详解">JUC工具类_Phaser详解</span>
            <span class="post-date" title="2022-12-10 22:56:48">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/JUC%E5%B7%A5%E5%85%B7%E7%B1%BB-Semaphore%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="JUC工具类_Semaphore详解">JUC工具类_Semaphore详解</span>
            <span class="post-date" title="2022-12-10 22:56:07">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/JUC%E5%B7%A5%E5%85%B7%E7%B1%BB-CyclicBarrier%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="JUC工具类_CyclicBarrier详解">JUC工具类_CyclicBarrier详解</span>
            <span class="post-date" title="2022-12-10 22:55:21">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/JUC%E5%B7%A5%E5%85%B7%E7%B1%BB-CountDownLatch%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="JUC工具类_CountDownLatch详解">JUC工具类_CountDownLatch详解</span>
            <span class="post-date" title="2022-12-10 22:54:36">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/JUC%E7%BA%BF%E7%A8%8B%E6%B1%A0-Fork-Join%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="JUC线程池_Fork_Join框架详解">JUC线程池_Fork_Join框架详解</span>
            <span class="post-date" title="2022-12-10 22:53:19">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/JUC%E7%BA%BF%E7%A8%8B%E6%B1%A0-ScheduledThreadPoolExecutor%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="JUC线程池_ScheduledThreadPoolExecutor详解">JUC线程池_ScheduledThreadPoolExecutor详解</span>
            <span class="post-date" title="2022-12-10 22:52:28">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/JUC%E7%BA%BF%E7%A8%8B%E6%B1%A0-ThreadPoolExecutor%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="JUC线程池_ThreadPoolExecutor详解">JUC线程池_ThreadPoolExecutor详解</span>
            <span class="post-date" title="2022-12-10 22:51:41">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/JUC%E7%BA%BF%E7%A8%8B%E6%B1%A0-FutureTask%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="JUC线程池_FutureTask详解">JUC线程池_FutureTask详解</span>
            <span class="post-date" title="2022-12-10 22:50:52">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/JUC%E9%9B%86%E5%90%88-BlockingQueue%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="JUC集合_BlockingQueue详解">JUC集合_BlockingQueue详解</span>
            <span class="post-date" title="2022-12-10 22:50:13">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/JUC%E9%9B%86%E5%90%88-ConcurrentLinkedQueue%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="JUC集合_ConcurrentLinkedQueue详解">JUC集合_ConcurrentLinkedQueue详解</span>
            <span class="post-date" title="2022-12-10 22:49:05">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/JUC%E9%9B%86%E5%90%88-CopyOnWriteArrayList%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="JUC集合_CopyOnWriteArrayList详解">JUC集合_CopyOnWriteArrayList详解</span>
            <span class="post-date" title="2022-12-10 22:48:13">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/JUC%E9%9B%86%E5%90%88-ConcurrentHashMap%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="JUC集合_ConcurrentHashMap详解">JUC集合_ConcurrentHashMap详解</span>
            <span class="post-date" title="2022-12-10 22:47:15">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/JUC%E9%94%81-ReentrantReadWriteLock%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="JUC锁_ReentrantReadWriteLock详解">JUC锁_ReentrantReadWriteLock详解</span>
            <span class="post-date" title="2022-12-10 22:46:04">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/JUC%E9%94%81-ReentrantLock%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="JUC锁_ReentrantLock详解">JUC锁_ReentrantLock详解</span>
            <span class="post-date" title="2022-12-10 22:45:06">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/JUC%E9%94%81-%E9%94%81%E6%A0%B8%E5%BF%83%E7%B1%BBAQS%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="JUC锁_锁核心类AQS详解">JUC锁_锁核心类AQS详解</span>
            <span class="post-date" title="2022-12-10 22:44:15">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/JUC%E9%94%81-LockSupport%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="JUC锁_LockSupport详解">JUC锁_LockSupport详解</span>
            <span class="post-date" title="2022-12-10 22:43:25">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/JUC%E5%8E%9F%E5%AD%90%E7%B1%BB-CAS-Unsafe%E5%92%8C%E5%8E%9F%E5%AD%90%E7%B1%BB%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="JUC原子类_CAS_Unsafe和原子类详解">JUC原子类_CAS_Unsafe和原子类详解</span>
            <span class="post-date" title="2022-12-10 22:42:34">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/JUC%E7%B1%BB%E6%B1%87%E6%80%BB%E5%92%8C%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%8D%97/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="JUC类汇总和学习指南">JUC类汇总和学习指南</span>
            <span class="post-date" title="2022-12-10 22:41:01">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/final%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="final详解">final详解</span>
            <span class="post-date" title="2022-12-10 22:39:53">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/volatile%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="volatile详解">volatile详解</span>
            <span class="post-date" title="2022-12-10 22:39:02">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/synchronized%E8%AF%A6%E8%A7%A3/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="synchronized详解">synchronized详解</span>
            <span class="post-date" title="2022-12-10 22:37:04">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="线程基础">线程基础</span>
            <span class="post-date" title="2022-12-10 22:31:59">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="理论基础">理论基础</span>
            <span class="post-date" title="2022-12-10 22:30:46">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA Java集合框架 "
           href="/2022/12/10/WeakHashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"
           data-tag="java,Collection,Map,WeakHashMap"
           data-author="" >
            <span class="post-title" title="WeakHashMap源码解析">WeakHashMap源码解析</span>
            <span class="post-date" title="2022-12-10 22:26:56">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA Java集合框架 "
           href="/2022/12/10/TreeSet-TreeMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"
           data-tag="java,Collection,Map,TreeSet,TreeMap"
           data-author="" >
            <span class="post-title" title="TreeSet&amp;TreeMap源码解析">TreeSet&amp;TreeMap源码解析</span>
            <span class="post-date" title="2022-12-10 22:25:45">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA Java集合框架 "
           href="/2022/12/10/LinkedHashSet-Map%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"
           data-tag="java,Collection,LinkedHashSet,Map"
           data-author="" >
            <span class="post-title" title="LinkedHashSet&amp;Map源码解析">LinkedHashSet&amp;Map源码解析</span>
            <span class="post-date" title="2022-12-10 22:24:33">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA Java集合框架 "
           href="/2022/12/10/HashSet-HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"
           data-tag="java,Collection,HashSet,HashMap"
           data-author="" >
            <span class="post-title" title="HashSet&amp;HashMap源码解析">HashSet&amp;HashMap源码解析</span>
            <span class="post-date" title="2022-12-10 22:23:24">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA Java集合框架 "
           href="/2022/12/10/PriorityQueue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"
           data-tag="java,Collection,PriorityQueue"
           data-author="" >
            <span class="post-title" title="PriorityQueue源码解析">PriorityQueue源码解析</span>
            <span class="post-date" title="2022-12-10 22:22:22">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA Java集合框架 "
           href="/2022/12/10/Stack-Queue%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"
           data-tag="java,Collection,Stack,Queue"
           data-author="" >
            <span class="post-title" title="Stack&amp;Queue源码解析">Stack&amp;Queue源码解析</span>
            <span class="post-date" title="2022-12-10 22:21:07">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA Java集合框架 "
           href="/2022/12/10/LinkedList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"
           data-tag="java,Collection,LinkedList"
           data-author="" >
            <span class="post-title" title="LinkedList源码解析">LinkedList源码解析</span>
            <span class="post-date" title="2022-12-10 22:19:50">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA Java集合框架 "
           href="/2022/12/10/ArrayList%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"
           data-tag="java,Collection,ArrayList"
           data-author="" >
            <span class="post-title" title="ArrayList源码解析">ArrayList源码解析</span>
            <span class="post-date" title="2022-12-10 22:18:49">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 Spring SpringBoot2.5.X系列 "
           href="/2022/12/10/SpringBoot%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3/"
           data-tag="java,spring,spring boot"
           data-author="" >
            <span class="post-title" title="SpringBoot知识体系详解">SpringBoot知识体系详解</span>
            <span class="post-date" title="2022-12-10 22:14:55">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 Spring SpringFrameWork5基础 "
           href="/2022/12/10/Spring%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3/"
           data-tag="java,spring"
           data-author="" >
            <span class="post-title" title="Spring框架知识体系详解">Spring框架知识体系详解</span>
            <span class="post-date" title="2022-12-10 22:10:47">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA Java集合框架 "
           href="/2022/12/10/Collection%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE/"
           data-tag="java,Collection"
           data-author="" >
            <span class="post-title" title="Collection类关系图">Collection类关系图</span>
            <span class="post-date" title="2022-12-10 21:59:49">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA基础 "
           href="/2022/12/10/SPI%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="SPI机制详解">SPI机制详解</span>
            <span class="post-date" title="2022-12-10 21:58:56">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA基础 "
           href="/2022/12/10/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="反射机制详解">反射机制详解</span>
            <span class="post-date" title="2022-12-10 21:57:59">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA基础 "
           href="/2022/12/10/%E5%BC%82%E5%B8%B8%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="异常机制详解">异常机制详解</span>
            <span class="post-date" title="2022-12-10 21:56:33">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA基础 "
           href="/2022/12/10/%E6%B3%A8%E8%A7%A3%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="注解机制详解">注解机制详解</span>
            <span class="post-date" title="2022-12-10 21:54:56">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA基础 "
           href="/2022/12/10/%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="泛型机制详解">泛型机制详解</span>
            <span class="post-date" title="2022-12-10 21:54:06">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA基础 "
           href="/2022/12/10/%E5%9B%BE%E8%B0%B1-Q-A/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="图谱&amp;Q/A">图谱&amp;Q/A</span>
            <span class="post-date" title="2022-12-10 21:53:16">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA基础 "
           href="/2022/12/10/%E7%9F%A5%E8%AF%86%E7%82%B9/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="知识点">知识点</span>
            <span class="post-date" title="2022-12-10 21:52:41">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA基础 "
           href="/2022/12/10/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"
           data-tag="java"
           data-author="" >
            <span class="post-title" title="面向对象">面向对象</span>
            <span class="post-date" title="2022-12-10 21:50:56">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 JAVA JAVA多线程 "
           href="/2022/12/10/Java%E5%B9%B6%E5%8F%91-Java%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E9%94%81/"
           data-tag="java,多线程"
           data-author="" >
            <span class="post-title" title="Java并发 - Java中所有的锁">Java并发 - Java中所有的锁</span>
            <span class="post-date" title="2022-12-10 21:25:40">2022/12/10</span>
        </a>
        
        
        <a  class="全部文章 工具 HEXO "
           href="/2022/12/10/HEXO%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"
           data-tag="hexo,tool"
           data-author="" >
            <span class="post-title" title="HEXO使用指南">HEXO使用指南</span>
            <span class="post-date" title="2022-12-10 19:02:24">2022/12/10</span>
        </a>
        
        <div id="no-item-tips">

        </div>
    </nav>
    <div id="outline-list">
    </div>
</div>

    </div>
    <div class="hide-list">
        <div class="semicircle" data-title="切换全屏 快捷键 s">
            <div class="brackets first"><</div>
            <div class="brackets">&gt;</div>
        </div>
    </div>
</aside>
<div id="post">
    <div class="pjax">
        <article id="post-JUC线程池-Fork-Join框架详解" class="article article-type-post" itemscope itemprop="blogPost">
    
        <h1 class="article-title">JUC线程池_Fork_Join框架详解</h1>
    
    <div class="article-meta">
        
        
        
        <span class="book">
            <i class="iconfont icon-category"></i>
            
            
            <a  data-rel="JAVA">JAVA</a> > 
            
            <a  data-rel="JAVA&lt;---&gt;JAVA多线程">JAVA多线程</a>
            
        </span>
        
        
        <span class="tag">
            <i class="iconfont icon-tag"></i>
            
            <a class="color5">java</a>
            
            <a class="color4">多线程</a>
            
        </span>
        
    </div>
    <div class="article-meta">
        
            发布时间 : <time class="date" title='最后更新: 2022-12-10 22:54:44'>2022-12-10 22:53</time>
        
    </div>
    <div class="article-meta">
        
        <span>字数:15.3k</span>
        
        
        <span id="busuanzi_container_page_pv">
            阅读 :<span id="busuanzi_value_page_pv">
                <span class="count-comment">
                    <span class="spinner">
                      <div class="cube1"></div>
                      <div class="cube2"></div>
                    </span>
                </span>
            </span>
        </span>
        
        
    </div>
    
    <div class="toc-ref">
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JUC%E7%BA%BF%E7%A8%8B%E6%B1%A0-Fork-x2F-Join%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3"><span class="toc-text">JUC线程池: Fork&#x2F;Join框架详解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%A6%E7%9D%80BAT%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%8E%BB%E7%90%86%E8%A7%A3Fork-x2F-Join%E6%A1%86%E6%9E%B6"><span class="toc-text">带着BAT大厂的面试问题去理解Fork&#x2F;Join框架</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fork-x2F-Join%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B"><span class="toc-text">Fork&#x2F;Join框架简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%8F%8A%E5%85%B3%E7%B3%BB"><span class="toc-text">三个模块及关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95-Divide-and-Conquer"><span class="toc-text">核心思想: 分治算法(Divide-and-Conquer)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-work-stealing-%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96-%E7%AE%97%E6%B3%95"><span class="toc-text">核心思想: work-stealing(工作窃取)算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Fork-x2F-Join-%E6%A1%86%E6%9E%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">Fork&#x2F;Join 框架的执行流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fork-x2F-Join%E7%B1%BB%E5%85%B3%E7%B3%BB"><span class="toc-text">Fork&#x2F;Join类关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoinPool%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-text">ForkJoinPool继承关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoinTask%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-text">ForkJoinTask继承关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fork-x2F-Join%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">Fork&#x2F;Join框架源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoinPool"><span class="toc-text">ForkJoinPool</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="toc-text">核心参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ForkJoinPool-WorkQueue-%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7"><span class="toc-text">ForkJoinPool.WorkQueue 中的相关属性:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ForkJoinTask"><span class="toc-text">ForkJoinTask</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0-1"><span class="toc-text">核心参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fork-x2F-Join%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-1"><span class="toc-text">Fork&#x2F;Join框架源码解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-%E5%A4%96%E9%83%A8%E4%BB%BB%E5%8A%A1-external-x2F-submissions-task-%E6%8F%90%E4%BA%A4"><span class="toc-text">执行流程 - 外部任务(external&#x2F;submissions task)提交</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#externalPush-ForkJoinTask-lt-gt-task"><span class="toc-text">externalPush(ForkJoinTask&lt;?&gt; task)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#externalSubmit-ForkJoinTask-lt-gt-task"><span class="toc-text">externalSubmit(ForkJoinTask&lt;?&gt; task)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#signalWork-WorkQueue-ws-WorkQueue-q"><span class="toc-text">signalWork(WorkQueue[] ws, WorkQueue q)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryAddWorker-long-c"><span class="toc-text">tryAddWorker(long c)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createWorker"><span class="toc-text">createWorker()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#registerWorker"><span class="toc-text">registerWorker()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-%E5%AD%90%E4%BB%BB%E5%8A%A1-Worker-task-%E6%8F%90%E4%BA%A4"><span class="toc-text">执行流程: 子任务(Worker task)提交</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ForkJoinTask-fork"><span class="toc-text">ForkJoinTask.fork()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ForkJoinPool-WorkQueue-push"><span class="toc-text">ForkJoinPool.WorkQueue.push()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C"><span class="toc-text">执行流程: 任务执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ForkJoinWorkerThread-run"><span class="toc-text">ForkJoinWorkerThread.run()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ForkJoinPool-runWorker-WorkQueue-w"><span class="toc-text">ForkJoinPool.runWorker(WorkQueue w)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ForkJoinPool-scan-WorkQueue-w-int-r"><span class="toc-text">ForkJoinPool.scan(WorkQueue w, int r)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ForkJoinPool-awaitWork-WorkQueue-w-int-r"><span class="toc-text">ForkJoinPool.awaitWork(WorkQueue w, int r)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WorkQueue-runTask"><span class="toc-text">WorkQueue.runTask()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ForkJoinPool-deregisterWorker-ForkJoinWorkerThread-wt-Throwable-ex"><span class="toc-text">ForkJoinPool.deregisterWorker(ForkJoinWorkerThread wt, Throwable ex)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E7%BB%93%E6%9E%9C-ForkJoinTask-join-x2F-ForkJoinTask-invoke"><span class="toc-text">获取任务结果 - ForkJoinTask.join() &#x2F; ForkJoinTask.invoke()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ForkJoinTask-externalAwaitDone"><span class="toc-text">ForkJoinTask.externalAwaitDone()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ForkJoinPool-awaitJoin"><span class="toc-text">ForkJoinPool.awaitJoin()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WorkQueue-tryRemoveAndExec-ForkJoinTask-lt-gt-task"><span class="toc-text">WorkQueue.tryRemoveAndExec(ForkJoinTask&lt;?&gt; task)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ForkJoinPool-helpStealer-WorkQueue-w-ForkJoinTask-lt-gt-task"><span class="toc-text">ForkJoinPool.helpStealer(WorkQueue w, ForkJoinTask&lt;?&gt; task)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ForkJoinPool-tryCompensate-WorkQueue-w"><span class="toc-text">ForkJoinPool.tryCompensate(WorkQueue w)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Fork-x2F-Join%E7%9A%84%E9%99%B7%E9%98%B1%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">Fork&#x2F;Join的陷阱与注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84fork"><span class="toc-text">避免不必要的fork()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8Ffork-%E3%80%81compute-%E3%80%81join-%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-text">注意fork()、compute()、join()的顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%AD%90%E4%BB%BB%E5%8A%A1%E7%B2%92%E5%BA%A6"><span class="toc-text">选择合适的子任务粒度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E9%87%8D%E9%87%8F%E7%BA%A7%E4%BB%BB%E5%8A%A1%E5%88%92%E5%88%86%E4%B8%8E%E7%BB%93%E6%9E%9C%E5%90%88%E5%B9%B6"><span class="toc-text">避免重量级任务划分与结果合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3"><span class="toc-text">再深入理解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9BJDK%E6%BA%90%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86Fork-x2F-Join%E6%80%9D%E6%83%B3"><span class="toc-text">有哪些JDK源码中使用了Fork&#x2F;Join思想?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8Executors%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%88%9B%E5%BB%BAForkJoinPool"><span class="toc-text">使用Executors工具类创建ForkJoinPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8EFork-x2F-Join%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-text">关于Fork&#x2F;Join异常处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9BFork-x2F-Join%E4%BE%8B%E5%AD%90"><span class="toc-text">一些Fork&#x2F;Join例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%87%E7%94%A8Fork-x2F-Join%E6%9D%A5%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%971-2-3-%E2%80%A6-10000%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-text">采用Fork&#x2F;Join来异步计算1+2+3+…+10000的结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="toc-text">实现斐波那契数列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-text">参考文章</span></a></li></ol>
    
<style>
    .left-col .switch-btn,
    .left-col .switch-area {
        display: none;
    }
    .toc-level-3 i,
    .toc-level-3 ol {
        display: none !important;
    }
</style>
</div>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JUC线程池-Fork-x2F-Join框架详解"><a href="#JUC线程池-Fork-x2F-Join框架详解" class="headerlink" title="JUC线程池: Fork&#x2F;Join框架详解"></a>JUC线程池: Fork&#x2F;Join框架详解</h2><blockquote>
<p>ForkJoinPool 是JDK 7加入的一个线程池类。Fork&#x2F;Join 技术是分治算法(Divide-and-Conquer)的并行实现，它是一项可以获得良好的并行性能的简单且高效的设计技术。目的是为了帮助我们更好地利用多处理器带来的好处，使用所有可用的运算能力来提升应用的性能。@pdai</p>
</blockquote>
<ul>
<li><a href="#juc%E7%BA%BF%E7%A8%8B%E6%B1%A0-forkjoin%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3">JUC线程池: Fork&#x2F;Join框架详解</a><ul>
<li><a href="#%E5%B8%A6%E7%9D%80bat%E5%A4%A7%E5%8E%82%E7%9A%84%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E5%8E%BB%E7%90%86%E8%A7%A3forkjoin%E6%A1%86%E6%9E%B6">带着BAT大厂的面试问题去理解Fork&#x2F;Join框架</a></li>
<li><a href="#forkjoin%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B">Fork&#x2F;Join框架简介</a><ul>
<li><a href="#%E4%B8%89%E4%B8%AA%E6%A8%A1%E5%9D%97%E5%8F%8A%E5%85%B3%E7%B3%BB">三个模块及关系</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95divide-and-conquer">核心思想: 分治算法(Divide-and-Conquer)</a></li>
<li><a href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3-work-stealing%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%E7%AE%97%E6%B3%95">核心思想: work-stealing(工作窃取)算法</a></li>
<li><a href="#forkjoin-%E6%A1%86%E6%9E%B6%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">Fork&#x2F;Join 框架的执行流程</a></li>
</ul>
</li>
<li><a href="#forkjoin%E7%B1%BB%E5%85%B3%E7%B3%BB">Fork&#x2F;Join类关系</a><ul>
<li><a href="#forkjoinpool%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB">ForkJoinPool继承关系</a></li>
<li><a href="#forkjointask%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB">ForkJoinTask继承关系</a></li>
</ul>
</li>
<li><a href="#forkjoin%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">Fork&#x2F;Join框架源码解析</a><ul>
<li><a href="#forkjoinpool">ForkJoinPool</a><ul>
<li><a href="#%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0">核心参数</a></li>
<li><a href="#forkjoinpoolworkqueue-%E4%B8%AD%E7%9A%84%E7%9B%B8%E5%85%B3%E5%B1%9E%E6%80%A7">ForkJoinPool.WorkQueue 中的相关属性:</a></li>
</ul>
</li>
<li><a href="#forkjointask">ForkJoinTask</a><ul>
<li><a href="#%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0-1">核心参数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#forkjoin%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-1">Fork&#x2F;Join框架源码解析</a><ul>
<li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">构造函数</a></li>
<li><a href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B---%E5%A4%96%E9%83%A8%E4%BB%BB%E5%8A%A1externalsubmissions-task%E6%8F%90%E4%BA%A4">执行流程 - 外部任务(external&#x2F;submissions task)提交</a><ul>
<li><a href="#externalpushforkjointask-task">externalPush(ForkJoinTask&lt;?&gt; task)</a></li>
<li><a href="#externalsubmitforkjointask-task">externalSubmit(ForkJoinTask&lt;?&gt; task)</a></li>
<li><a href="#signalworkworkqueue-ws-workqueue-q">signalWork(WorkQueue[] ws, WorkQueue q)</a></li>
<li><a href="#tryaddworkerlong-c">tryAddWorker(long c)</a></li>
<li><a href="#createworker">createWorker()</a></li>
<li><a href="#registerworker">registerWorker()</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93">小结</a></li>
</ul>
</li>
<li><a href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-%E5%AD%90%E4%BB%BB%E5%8A%A1worker-task%E6%8F%90%E4%BA%A4">执行流程: 子任务(Worker task)提交</a><ul>
<li><a href="#forkjointaskfork">ForkJoinTask.fork()</a></li>
<li><a href="#forkjoinpoolworkqueuepush">ForkJoinPool.WorkQueue.push()</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-1">小结</a></li>
</ul>
</li>
<li><a href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B-%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C">执行流程: 任务执行</a><ul>
<li><a href="#forkjoinworkerthreadrun">ForkJoinWorkerThread.run()</a></li>
<li><a href="#forkjoinpoolrunworkerworkqueue-w">ForkJoinPool.runWorker(WorkQueue w)</a></li>
<li><a href="#forkjoinpoolscanworkqueue-w-int-r">ForkJoinPool.scan(WorkQueue w, int r)</a></li>
<li><a href="#forkjoinpoolawaitworkworkqueue-w-int-r">ForkJoinPool.awaitWork(WorkQueue w, int r)</a></li>
<li><a href="#workqueueruntask">WorkQueue.runTask()</a></li>
<li><a href="#forkjoinpoolderegisterworkerforkjoinworkerthread-wt-throwable-ex">ForkJoinPool.deregisterWorker(ForkJoinWorkerThread wt, Throwable ex)</a></li>
<li><a href="#%E5%B0%8F%E7%BB%93-2">小结</a></li>
</ul>
</li>
<li><a href="#%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1%E7%BB%93%E6%9E%9C---forkjointaskjoin--forkjointaskinvoke">获取任务结果 - ForkJoinTask.join() &#x2F; ForkJoinTask.invoke()</a><ul>
<li><a href="#forkjointaskexternalawaitdone">ForkJoinTask.externalAwaitDone()</a></li>
<li><a href="#forkjoinpoolawaitjoin">ForkJoinPool.awaitJoin()</a></li>
<li><a href="#workqueuetryremoveandexecforkjointask-task">WorkQueue.tryRemoveAndExec(ForkJoinTask&lt;?&gt; task)</a></li>
<li><a href="#forkjoinpoolhelpstealerworkqueue-w-forkjointask-task">ForkJoinPool.helpStealer(WorkQueue w, ForkJoinTask&lt;?&gt; task)</a></li>
<li><a href="#forkjoinpooltrycompensateworkqueue-w">ForkJoinPool.tryCompensate(WorkQueue w)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#forkjoin%E7%9A%84%E9%99%B7%E9%98%B1%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">Fork&#x2F;Join的陷阱与注意事项</a><ul>
<li><a href="#%E9%81%BF%E5%85%8D%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84fork">避免不必要的fork()</a></li>
<li><a href="#%E6%B3%A8%E6%84%8Fforkcomputejoin%E7%9A%84%E9%A1%BA%E5%BA%8F">注意fork()、compute()、join()的顺序</a></li>
<li><a href="#%E9%80%89%E6%8B%A9%E5%90%88%E9%80%82%E7%9A%84%E5%AD%90%E4%BB%BB%E5%8A%A1%E7%B2%92%E5%BA%A6">选择合适的子任务粒度</a></li>
<li><a href="#%E9%81%BF%E5%85%8D%E9%87%8D%E9%87%8F%E7%BA%A7%E4%BB%BB%E5%8A%A1%E5%88%92%E5%88%86%E4%B8%8E%E7%BB%93%E6%9E%9C%E5%90%88%E5%B9%B6">避免重量级任务划分与结果合并</a></li>
</ul>
</li>
<li><a href="#%E5%86%8D%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3">再深入理解</a><ul>
<li><a href="#%E6%9C%89%E5%93%AA%E4%BA%9Bjdk%E6%BA%90%E7%A0%81%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BA%86forkjoin%E6%80%9D%E6%83%B3">有哪些JDK源码中使用了Fork&#x2F;Join思想?</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8executors%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%88%9B%E5%BB%BAforkjoinpool">使用Executors工具类创建ForkJoinPool</a></li>
<li><a href="#%E5%85%B3%E4%BA%8Eforkjoin%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">关于Fork&#x2F;Join异常处理</a></li>
</ul>
</li>
<li><a href="#%E4%B8%80%E4%BA%9Bforkjoin%E4%BE%8B%E5%AD%90">一些Fork&#x2F;Join例子</a><ul>
<li><a href="#%E9%87%87%E7%94%A8forkjoin%E6%9D%A5%E5%BC%82%E6%AD%A5%E8%AE%A1%E7%AE%9712310000%E7%9A%84%E7%BB%93%E6%9E%9C">采用Fork&#x2F;Join来异步计算1+2+3+…+10000的结果</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97">实现斐波那契数列</a></li>
</ul>
</li>
<li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">参考文章</a></li>
</ul>
</li>
</ul>
<h2 id="带着BAT大厂的面试问题去理解Fork-x2F-Join框架"><a href="#带着BAT大厂的面试问题去理解Fork-x2F-Join框架" class="headerlink" title="带着BAT大厂的面试问题去理解Fork&#x2F;Join框架"></a>带着BAT大厂的面试问题去理解Fork&#x2F;Join框架</h2><p>提示</p>
<p>请带着这些问题继续后文，会很大程度上帮助你更好的理解Fork&#x2F;Join框架。@pdai</p>
<ul>
<li>Fork&#x2F;Join主要用来解决什么样的问题?</li>
<li>Fork&#x2F;Join框架是在哪个JDK版本中引入的?</li>
<li>Fork&#x2F;Join框架主要包含哪三个模块? 模块之间的关系是怎么样的?</li>
<li>ForkJoinPool类继承关系?</li>
<li>ForkJoinTask抽象类继承关系? 在实际运用中，我们一般都会继承 RecursiveTask 、RecursiveAction 或 CountedCompleter 来实现我们的业务需求，而不会直接继承 ForkJoinTask 类。</li>
<li>整个Fork&#x2F;Join 框架的执行流程&#x2F;运行机制是怎么样的?</li>
<li>具体阐述Fork&#x2F;Join的分治思想和work-stealing 实现方式?</li>
<li>有哪些JDK源码中使用了Fork&#x2F;Join思想?</li>
<li>如何使用Executors工具类创建ForkJoinPool?</li>
<li>写一个例子: 用ForkJoin方式实现1+2+3+…+100000?</li>
<li>Fork&#x2F;Join在使用时有哪些注意事项? 结合JDK中的斐波那契数列实例具体说明。</li>
</ul>
<h2 id="Fork-x2F-Join框架简介"><a href="#Fork-x2F-Join框架简介" class="headerlink" title="Fork&#x2F;Join框架简介"></a>Fork&#x2F;Join框架简介</h2><p>Fork&#x2F;Join框架是Java并发工具包中的一种可以将一个大任务拆分为很多小任务来异步执行的工具，自JDK1.7引入。</p>
<h3 id="三个模块及关系"><a href="#三个模块及关系" class="headerlink" title="三个模块及关系"></a>三个模块及关系</h3><p>Fork&#x2F;Join框架主要包含三个模块:</p>
<ul>
<li>任务对象: <code>ForkJoinTask</code> (包括<code>RecursiveTask</code>、<code>RecursiveAction</code> 和 <code>CountedCompleter</code>)</li>
<li>执行Fork&#x2F;Join任务的线程: <code>ForkJoinWorkerThread</code></li>
<li>线程池: <code>ForkJoinPool</code></li>
</ul>
<p>这三者的关系是: ForkJoinPool可以通过池中的ForkJoinWorkerThread来处理ForkJoinTask任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// from 《A Java Fork/Join Framework》Dong Lea</span></span><br><span class="line">Result <span class="title function_">solve</span><span class="params">(Problem problem)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (problem is small)</span><br><span class="line"> 		directly solve problem</span><br><span class="line"> 	<span class="keyword">else</span> &#123;</span><br><span class="line"> 		split problem into independent parts</span><br><span class="line"> 		fork <span class="keyword">new</span> <span class="title class_">subtasks</span> to solve each part</span><br><span class="line"> 		join all subtasks</span><br><span class="line"> 		compose result from subresults</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ForkJoinPool 只接收 ForkJoinTask 任务(在实际使用中，也可以接收 Runnable&#x2F;Callable 任务，但在真正运行时，也会把这些任务封装成 ForkJoinTask 类型的任务)，RecursiveTask 是 ForkJoinTask 的子类，是一个可以递归执行的 ForkJoinTask，RecursiveAction 是一个无返回值的 RecursiveTask，CountedCompleter 在任务完成执行后会触发执行一个自定义的钩子函数。</p>
<p>在实际运用中，我们一般都会继承 <code>RecursiveTask</code> 、<code>RecursiveAction</code> 或 <code>CountedCompleter</code> 来实现我们的业务需求，而不会直接继承 ForkJoinTask 类。</p>
<h3 id="核心思想-分治算法-Divide-and-Conquer"><a href="#核心思想-分治算法-Divide-and-Conquer" class="headerlink" title="核心思想: 分治算法(Divide-and-Conquer)"></a>核心思想: 分治算法(Divide-and-Conquer)</h3><p>分治算法(Divide-and-Conquer)把任务递归的拆分为各个子任务，这样可以更好的利用系统资源，尽可能的使用所有可用的计算能力来提升应用性能。首先看一下 Fork&#x2F;Join 框架的任务运行机制:</p>
<p><img src="/2022/12/10/JUC%E7%BA%BF%E7%A8%8B%E6%B1%A0-Fork-Join%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/java-thread-x-forkjoin-2.png"></p>
<ul>
<li>这里也可以一并看下: <a target="_blank" rel="noopener" href="https://www.pdai.tech/md/algorithm/alg-core-divide-and-conquer.html">算法思想 - 分治算法</a></li>
</ul>
<h3 id="核心思想-work-stealing-工作窃取-算法"><a href="#核心思想-work-stealing-工作窃取-算法" class="headerlink" title="核心思想: work-stealing(工作窃取)算法"></a>核心思想: work-stealing(工作窃取)算法</h3><p>work-stealing(工作窃取)算法: 线程池内的所有工作线程都尝试找到并执行已经提交的任务，或者是被其他活动任务创建的子任务(如果不存在就阻塞等待)。这种特性使得 ForkJoinPool 在运行多个可以产生子任务的任务，或者是提交的许多小任务时效率更高。尤其是构建异步模型的 ForkJoinPool 时，对不需要合并(join)的事件类型任务也非常适用。</p>
<p>在 ForkJoinPool 中，线程池中每个工作线程(ForkJoinWorkerThread)都对应一个任务队列(WorkQueue)，工作线程优先处理来自自身队列的任务(LIFO或FIFO顺序，参数 mode 决定)，然后以FIFO的顺序随机窃取其他队列中的任务。</p>
<p>具体思路如下:</p>
<ul>
<li>每个线程都有自己的一个WorkQueue，该工作队列是一个双端队列。</li>
<li>队列支持三个功能push、pop、poll</li>
<li>push&#x2F;pop只能被队列的所有者线程调用，而poll可以被其他线程调用。</li>
<li>划分的子任务调用fork时，都会被push到自己的队列中。</li>
<li>默认情况下，工作线程从自己的双端队列获出任务并执行。</li>
<li>当自己的队列为空时，线程随机从另一个线程的队列末尾调用poll方法窃取任务。</li>
</ul>
<p><img src="/2022/12/10/JUC%E7%BA%BF%E7%A8%8B%E6%B1%A0-Fork-Join%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/java-thread-x-forkjoin-3.png"></p>
<h3 id="Fork-x2F-Join-框架的执行流程"><a href="#Fork-x2F-Join-框架的执行流程" class="headerlink" title="Fork&#x2F;Join 框架的执行流程"></a>Fork&#x2F;Join 框架的执行流程</h3><p>上图可以看出ForkJoinPool 中的任务执行分两种:</p>
<ul>
<li>直接通过 FJP 提交的外部任务(external&#x2F;submissions task)，存放在 workQueues 的偶数槽位；</li>
<li>通过内部 fork 分割的子任务(Worker task)，存放在 workQueues 的奇数槽位。</li>
</ul>
<p>那Fork&#x2F;Join 框架的执行流程是什么样的?</p>
<p><img src="/2022/12/10/JUC%E7%BA%BF%E7%A8%8B%E6%B1%A0-Fork-Join%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/java-thread-x-forkjoin-5.png"></p>
<blockquote>
<p>后续的源码解析将围绕上图进行。</p>
</blockquote>
<h2 id="Fork-x2F-Join类关系"><a href="#Fork-x2F-Join类关系" class="headerlink" title="Fork&#x2F;Join类关系"></a>Fork&#x2F;Join类关系</h2><h3 id="ForkJoinPool继承关系"><a href="#ForkJoinPool继承关系" class="headerlink" title="ForkJoinPool继承关系"></a>ForkJoinPool继承关系</h3><p><img src="/2022/12/10/JUC%E7%BA%BF%E7%A8%8B%E6%B1%A0-Fork-Join%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/java-thread-x-forkjoin-1.png"></p>
<p>内部类介绍:</p>
<ul>
<li><p>ForkJoinWorkerThreadFactory: 内部线程工厂接口，用于创建工作线程ForkJoinWorkerThread</p>
</li>
<li><p>DefaultForkJoinWorkerThreadFactory: ForkJoinWorkerThreadFactory 的默认实现类</p>
</li>
<li><p>InnocuousForkJoinWorkerThreadFactory: 实现了 ForkJoinWorkerThreadFactory，无许可线程工厂，当系统变量中有系统安全管理相关属性时，默认使用这个工厂创建工作线程。</p>
</li>
<li><p>EmptyTask: 内部占位类，用于替换队列中 join 的任务。</p>
</li>
<li><p>ManagedBlocker: 为 ForkJoinPool 中的任务提供扩展管理并行数的接口，一般用在可能会阻塞的任务(如在 Phaser 中用于等待 phase 到下一个generation)。</p>
</li>
<li><p>WorkQueue: ForkJoinPool 的核心数据结构，本质上是work-stealing 模式的双端任务队列，内部存放 ForkJoinTask 对象任务，使用 @Contented 注解修饰防止伪共享。</p>
<ul>
<li>工作线程在运行中产生新的任务(通常是因为调用了 fork())时，此时可以把 WorkQueue 的数据结构视为一个栈，新的任务会放入栈顶(top 位)；工作线程在处理自己工作队列的任务时，按照 LIFO 的顺序。</li>
<li>工作线程在处理自己的工作队列同时，会尝试窃取一个任务(可能是来自于刚刚提交到 pool 的任务，或是来自于其他工作线程的队列任务)，此时可以把 WorkQueue 的数据结构视为一个 FIFO 的队列，窃取的任务位于其他线程的工作队列的队首(base位)。</li>
</ul>
</li>
<li><p>伪共享状态: 缓存系统中是以缓存行(cache line)为单位存储的。缓存行是2的整数幂个连续字节，一般为32-256个字节。最常见的缓存行大小是64个字节。当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会无意中影响彼此的性能，这就是伪共享。</p>
</li>
</ul>
<h3 id="ForkJoinTask继承关系"><a href="#ForkJoinTask继承关系" class="headerlink" title="ForkJoinTask继承关系"></a>ForkJoinTask继承关系</h3><p><img src="/2022/12/10/JUC%E7%BA%BF%E7%A8%8B%E6%B1%A0-Fork-Join%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/java-thread-x-forkjoin-4.png"></p>
<p>ForkJoinTask 实现了 Future 接口，说明它也是一个可取消的异步运算任务，实际上ForkJoinTask 是 Future 的轻量级实现，主要用在纯粹是计算的函数式任务或者操作完全独立的对象计算任务。fork 是主运行方法，用于异步执行；而 join 方法在任务结果计算完毕之后才会运行，用来合并或返回计算结果。 其内部类都比较简单，ExceptionNode 是用于存储任务执行期间的异常信息的单向链表；其余四个类是为 Runnable&#x2F;Callable 任务提供的适配器类，用于把 Runnable&#x2F;Callable 转化为 ForkJoinTask 类型的任务(因为 ForkJoinPool 只可以运行 ForkJoinTask 类型的任务)。</p>
<h2 id="Fork-x2F-Join框架源码解析"><a href="#Fork-x2F-Join框架源码解析" class="headerlink" title="Fork&#x2F;Join框架源码解析"></a>Fork&#x2F;Join框架源码解析</h2><blockquote>
<p>分析思路: 在对类层次结构有了解以后，我们先看下内部核心参数，然后分析上述流程图。会分4个部分:</p>
</blockquote>
<ul>
<li>首先介绍任务的提交流程 - 外部任务(external&#x2F;submissions task)提交</li>
<li>然后介绍任务的提交流程 - 子任务(Worker task)提交</li>
<li>再分析任务的执行过程(ForkJoinWorkerThread.run()到ForkJoinTask.doExec()这一部分)；</li>
<li>最后介绍任务的结果获取(ForkJoinTask.join()和ForkJoinTask.invoke())</li>
</ul>
<h3 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h3><h4 id="核心参数"><a href="#核心参数" class="headerlink" title="核心参数"></a>核心参数</h4><p>在后面的源码解析中，我们会看到大量的位运算，这些位运算都是通过我们接下来介绍的一些常量参数来计算的。</p>
<p>例如，如果要更新活跃线程数，使用公式(UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; c)；c 代表当前 ctl，UC_MASK 和 SP_MASK 分别是高位和低位掩码，AC_UNIT 为活跃线程的增量数，使用(UC_MASK &amp; (c + AC_UNIT))就可以计算出高32位，然后再加上低32位(SP_MASK &amp; c)，就拼接成了一个新的ctl。</p>
<p>这些运算的可读性很差，看起来有些复杂。在后面源码解析中有位运算的地方我都会加上注释，大家只需要了解它们的作用即可。</p>
<p>ForkJoinPool 与 内部类 WorkQueue 共享的一些常量:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constants shared across ForkJoinPool and WorkQueue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 限定参数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SMASK</span> <span class="operator">=</span> <span class="number">0xffff</span>;        <span class="comment">//  低位掩码，也是最大索引位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_CAP</span> <span class="operator">=</span> <span class="number">0x7fff</span>;        <span class="comment">//  工作线程最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EVENMASK</span> <span class="operator">=</span> <span class="number">0xfffe</span>;        <span class="comment">//  偶数低位掩码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SQMASK</span> <span class="operator">=</span> <span class="number">0x007e</span>;        <span class="comment">//  workQueues 数组最多64个槽位</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ctl 子域和 WorkQueue.scanState 的掩码和标志位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SCANNING</span> <span class="operator">=</span> <span class="number">1</span>;             <span class="comment">// 标记是否正在运行任务</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INACTIVE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;       <span class="comment">// 失活状态  负数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SS_SEQ</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">16</span>;       <span class="comment">// 版本戳，防止ABA问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ForkJoinPool.config 和 WorkQueue.config 的配置信息标记</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MODE_MASK</span> <span class="operator">=</span> <span class="number">0xffff</span> &lt;&lt; <span class="number">16</span>;  <span class="comment">// 模式掩码</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LIFO_QUEUE</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//LIFO队列</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">FIFO_QUEUE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">16</span>;<span class="comment">//FIFO队列</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHARED_QUEUE</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;       <span class="comment">// 共享模式队列，负数</span></span><br></pre></td></tr></table></figure>

<p>ForkJoinPool 中的相关常量和实例字段:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  低位和高位掩码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SP_MASK</span> <span class="operator">=</span> <span class="number">0xffffffffL</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">UC_MASK</span> <span class="operator">=</span> ~SP_MASK;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 活跃线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">AC_SHIFT</span> <span class="operator">=</span> <span class="number">48</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">AC_UNIT</span> <span class="operator">=</span> <span class="number">0x0001L</span> &lt;&lt; AC_SHIFT; <span class="comment">//活跃线程数增量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">AC_MASK</span> <span class="operator">=</span> <span class="number">0xffffL</span> &lt;&lt; AC_SHIFT; <span class="comment">//活跃线程数掩码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TC_SHIFT</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">TC_UNIT</span> <span class="operator">=</span> <span class="number">0x0001L</span> &lt;&lt; TC_SHIFT; <span class="comment">//工作线程数增量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">TC_MASK</span> <span class="operator">=</span> <span class="number">0xffffL</span> &lt;&lt; TC_SHIFT; <span class="comment">//掩码</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ADD_WORKER</span> <span class="operator">=</span> <span class="number">0x0001L</span> &lt;&lt; (TC_SHIFT + <span class="number">15</span>);  <span class="comment">// 创建工作线程标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 池状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RSLOCK</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RSIGNAL</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STARTED</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">29</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例字段</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">long</span> ctl;                   <span class="comment">// 主控制参数</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> runState;               <span class="comment">// 运行状态锁</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> config;                    <span class="comment">// 并行度|模式</span></span><br><span class="line"><span class="type">int</span> indexSeed;                       <span class="comment">// 用于生成工作线程索引</span></span><br><span class="line"><span class="keyword">volatile</span> WorkQueue[] workQueues;     <span class="comment">// 主对象注册信息，workQueue</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinWorkerThreadFactory factory;<span class="comment">// 线程工厂</span></span><br><span class="line"><span class="keyword">final</span> UncaughtExceptionHandler ueh;  <span class="comment">// 每个工作线程的异常信息</span></span><br><span class="line"><span class="keyword">final</span> String workerNamePrefix;       <span class="comment">// 用于创建工作线程的名称</span></span><br><span class="line"><span class="keyword">volatile</span> AtomicLong stealCounter;    <span class="comment">// 偷取任务总数，也可作为同步监视器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 静态初始化字段 */</span></span><br><span class="line"><span class="comment">//线程工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ForkJoinWorkerThreadFactory defaultForkJoinWorkerThreadFactory;</span><br><span class="line"><span class="comment">//启动或杀死线程的方法调用者的权限</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RuntimePermission modifyThreadPermission;</span><br><span class="line"><span class="comment">// 公共静态pool</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ForkJoinPool common;</span><br><span class="line"><span class="comment">//并行度，对应内部common池</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> commonParallelism;</span><br><span class="line"><span class="comment">//备用线程数，在tryCompensate中使用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> commonMaxSpares;</span><br><span class="line"><span class="comment">//创建workerNamePrefix(工作线程名称前缀)时的序号</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> poolNumberSequence;</span><br><span class="line"><span class="comment">//线程阻塞等待新的任务的超时值(以纳秒为单位)，默认2秒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">IDLE_TIMEOUT</span> <span class="operator">=</span> <span class="number">2000L</span> * <span class="number">1000L</span> * <span class="number">1000L</span>; <span class="comment">// 2sec</span></span><br><span class="line"><span class="comment">//空闲超时时间，防止timer未命中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">TIMEOUT_SLOP</span> <span class="operator">=</span> <span class="number">20L</span> * <span class="number">1000L</span> * <span class="number">1000L</span>;  <span class="comment">// 20ms</span></span><br><span class="line"><span class="comment">//默认备用线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_COMMON_MAX_SPARES</span> <span class="operator">=</span> <span class="number">256</span>;</span><br><span class="line"><span class="comment">//阻塞前自旋的次数，用在在awaitRunStateLock和awaitWork中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SPINS</span>  <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//indexSeed的增量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SEED_INCREMENT</span> <span class="operator">=</span> <span class="number">0x9e3779b9</span>;</span><br></pre></td></tr></table></figure>

<p>说明: ForkJoinPool 的内部状态都是通过一个64位的 long 型 变量ctl来存储，它由四个16位的子域组成:</p>
<ul>
<li>AC: 正在运行工作线程数减去目标并行度，高16位</li>
<li>TC: 总工作线程数减去目标并行度，中高16位</li>
<li>SS: 栈顶等待线程的版本计数和状态，中低16位</li>
<li>ID: 栈顶 WorkQueue 在池中的索引(poolIndex)，低16位</li>
</ul>
<p>在后面的源码解析中，某些地方也提取了ctl的低32位(sp&#x3D;(int)ctl)来检查工作线程状态，例如，当sp不为0时说明当前还有空闲工作线程。</p>
<h4 id="ForkJoinPool-WorkQueue-中的相关属性"><a href="#ForkJoinPool-WorkQueue-中的相关属性" class="headerlink" title="ForkJoinPool.WorkQueue 中的相关属性:"></a>ForkJoinPool.WorkQueue 中的相关属性:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始队列容量，2的幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INITIAL_QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">13</span>;</span><br><span class="line"><span class="comment">//最大队列容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_QUEUE_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">26</span>; <span class="comment">// 64M</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例字段</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> scanState;    <span class="comment">// Woker状态, &lt;0: inactive; odd:scanning</span></span><br><span class="line"><span class="type">int</span> stackPred;             <span class="comment">// 记录前一个栈顶的ctl</span></span><br><span class="line"><span class="type">int</span> nsteals;               <span class="comment">// 偷取任务数</span></span><br><span class="line"><span class="type">int</span> hint;                  <span class="comment">// 记录偷取者索引，初始为随机索引</span></span><br><span class="line"><span class="type">int</span> config;                <span class="comment">// 池索引和模式</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> qlock;        <span class="comment">// 1: locked, &lt; 0: terminate; else 0</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> base;         <span class="comment">//下一个poll操作的索引(栈底/队列头)</span></span><br><span class="line"><span class="type">int</span> top;                   <span class="comment">//  下一个push操作的索引(栈顶/队列尾)</span></span><br><span class="line">ForkJoinTask&lt;?&gt;[] array;   <span class="comment">// 任务数组</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinPool pool;   <span class="comment">// the containing pool (may be null)</span></span><br><span class="line"><span class="keyword">final</span> ForkJoinWorkerThread owner; <span class="comment">// 当前工作队列的工作线程，共享模式下为null</span></span><br><span class="line"><span class="keyword">volatile</span> Thread parker;    <span class="comment">// 调用park阻塞期间为owner，其他情况为null</span></span><br><span class="line"><span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentJoin;  <span class="comment">// 记录被join过来的任务</span></span><br><span class="line"><span class="keyword">volatile</span> ForkJoinTask&lt;?&gt; currentSteal; <span class="comment">// 记录从其他工作队列偷取过来的任务</span></span><br></pre></td></tr></table></figure>

<h3 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h3><h4 id="核心参数-1"><a href="#核心参数-1" class="headerlink" title="核心参数"></a>核心参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 任务运行状态 */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> status; <span class="comment">// 任务运行状态</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DONE_MASK</span>   <span class="operator">=</span> <span class="number">0xf0000000</span>;  <span class="comment">// 任务完成状态标志位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NORMAL</span>      <span class="operator">=</span> <span class="number">0xf0000000</span>;  <span class="comment">// must be negative</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span>   <span class="operator">=</span> <span class="number">0xc0000000</span>;  <span class="comment">// must be &lt; NORMAL</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXCEPTIONAL</span> <span class="operator">=</span> <span class="number">0x80000000</span>;  <span class="comment">// must be &lt; CANCELLED</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>      <span class="operator">=</span> <span class="number">0x00010000</span>;  <span class="comment">// must be &gt;= 1 &lt;&lt; 16 等待信号</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SMASK</span>       <span class="operator">=</span> <span class="number">0x0000ffff</span>;  <span class="comment">//  低位掩码</span></span><br></pre></td></tr></table></figure>

<h2 id="Fork-x2F-Join框架源码解析-1"><a href="#Fork-x2F-Join框架源码解析-1" class="headerlink" title="Fork&#x2F;Join框架源码解析"></a>Fork&#x2F;Join框架源码解析</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ForkJoinPool</span><span class="params">(<span class="type">int</span> parallelism,</span></span><br><span class="line"><span class="params">                    ForkJoinWorkerThreadFactory factory,</span></span><br><span class="line"><span class="params">                    UncaughtExceptionHandler handler,</span></span><br><span class="line"><span class="params">                    <span class="type">boolean</span> asyncMode)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(checkParallelism(parallelism),</span><br><span class="line">            checkFactory(factory),</span><br><span class="line">            handler,</span><br><span class="line">            asyncMode ? FIFO_QUEUE : LIFO_QUEUE,</span><br><span class="line">            <span class="string">&quot;ForkJoinPool-&quot;</span> + nextPoolId() + <span class="string">&quot;-worker-&quot;</span>);</span><br><span class="line">    checkPermission();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: 在 ForkJoinPool 中我们可以自定义四个参数:</p>
<ul>
<li>parallelism: 并行度，默认为CPU数，最小为1</li>
<li>factory: 工作线程工厂；</li>
<li>handler: 处理工作线程运行任务时的异常情况类，默认为null；</li>
<li>asyncMode: 是否为异步模式，默认为 false。如果为true，表示子任务的执行遵循 FIFO 顺序并且任务不能被合并(join)，这种模式适用于工作线程只运行事件类型的异步任务。</li>
</ul>
<p>在多数场景使用时，如果没有太强的业务需求，我们一般直接使用 ForkJoinPool 中的common池，在JDK1.8之后提供了ForkJoinPool.commonPool()方法可以直接使用common池，来看一下它的构造:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ForkJoinPool <span class="title function_">makeCommonPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">parallelism</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">ForkJoinWorkerThreadFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">UncaughtExceptionHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;  <span class="comment">// ignore exceptions in accessing/parsing</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">pp</span> <span class="operator">=</span> System.getProperty</span><br><span class="line">                (<span class="string">&quot;java.util.concurrent.ForkJoinPool.common.parallelism&quot;</span>);<span class="comment">//并行度</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">fp</span> <span class="operator">=</span> System.getProperty</span><br><span class="line">                (<span class="string">&quot;java.util.concurrent.ForkJoinPool.common.threadFactory&quot;</span>);<span class="comment">//线程工厂</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">hp</span> <span class="operator">=</span> System.getProperty</span><br><span class="line">                (<span class="string">&quot;java.util.concurrent.ForkJoinPool.common.exceptionHandler&quot;</span>);<span class="comment">//异常处理类</span></span><br><span class="line">        <span class="keyword">if</span> (pp != <span class="literal">null</span>)</span><br><span class="line">            parallelism = Integer.parseInt(pp);</span><br><span class="line">        <span class="keyword">if</span> (fp != <span class="literal">null</span>)</span><br><span class="line">            factory = ((ForkJoinWorkerThreadFactory) ClassLoader.</span><br><span class="line">                    getSystemClassLoader().loadClass(fp).newInstance());</span><br><span class="line">        <span class="keyword">if</span> (hp != <span class="literal">null</span>)</span><br><span class="line">            handler = ((UncaughtExceptionHandler) ClassLoader.</span><br><span class="line">                    getSystemClassLoader().loadClass(hp).newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() == <span class="literal">null</span>)</span><br><span class="line">            factory = defaultForkJoinWorkerThreadFactory;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// use security-managed default</span></span><br><span class="line">            factory = <span class="keyword">new</span> <span class="title class_">InnocuousForkJoinWorkerThreadFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (parallelism &lt; <span class="number">0</span> &amp;&amp; <span class="comment">// default 1 less than #cores</span></span><br><span class="line">            (parallelism = Runtime.getRuntime().availableProcessors() - <span class="number">1</span>) &lt;= <span class="number">0</span>)</span><br><span class="line">        parallelism = <span class="number">1</span>;<span class="comment">//默认并行度为1</span></span><br><span class="line">    <span class="keyword">if</span> (parallelism &gt; MAX_CAP)</span><br><span class="line">        parallelism = MAX_CAP;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(parallelism, factory, handler, LIFO_QUEUE,</span><br><span class="line">            <span class="string">&quot;ForkJoinPool.commonPool-worker-&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用common pool的优点就是我们可以通过指定系统参数的方式定义“并行度、线程工厂和异常处理类”；并且它使用的是同步模式，也就是说可以支持任务合并(join)。</p>
<h3 id="执行流程-外部任务-external-x2F-submissions-task-提交"><a href="#执行流程-外部任务-external-x2F-submissions-task-提交" class="headerlink" title="执行流程 - 外部任务(external&#x2F;submissions task)提交"></a>执行流程 - 外部任务(external&#x2F;submissions task)提交</h3><p>向 ForkJoinPool 提交任务有三种方式:</p>
<ul>
<li>invoke()会等待任务计算完毕并返回计算结果；</li>
<li>execute()是直接向池提交一个任务来异步执行，无返回结果；</li>
<li>submit()也是异步执行，但是会返回提交的任务，在适当的时候可通过task.get()获取执行结果。</li>
</ul>
<p>这三种提交方式都都是调用externalPush()方法来完成，所以接下来我们将从externalPush()方法开始逐步分析外部任务的执行过程。</p>
<h4 id="externalPush-ForkJoinTask-lt-gt-task"><a href="#externalPush-ForkJoinTask-lt-gt-task" class="headerlink" title="externalPush(ForkJoinTask&lt;?&gt; task)"></a>externalPush(ForkJoinTask&lt;?&gt; task)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加给定任务到submission队列中</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">externalPush</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;</span><br><span class="line">    WorkQueue[] ws;</span><br><span class="line">    WorkQueue q;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> ThreadLocalRandom.getProbe();<span class="comment">//探针值，用于计算WorkQueue槽位索引</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> runState;</span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="literal">null</span> &amp;&amp; (m = (ws.length - <span class="number">1</span>)) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (q = ws[m &amp; r &amp; SQMASK]) != <span class="literal">null</span> &amp;&amp; r != <span class="number">0</span> &amp;&amp; rs &gt; <span class="number">0</span> &amp;&amp; <span class="comment">//获取随机偶数槽位的workQueue</span></span><br><span class="line">            U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//锁定workQueue</span></span><br><span class="line">        ForkJoinTask&lt;?&gt;[] a;</span><br><span class="line">        <span class="type">int</span> am, n, s;</span><br><span class="line">        <span class="keyword">if</span> ((a = q.array) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                (am = a.length - <span class="number">1</span>) &gt; (n = (s = q.top) - q.base)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> ((am &amp; s) &lt;&lt; ASHIFT) + ABASE;<span class="comment">//计算任务索引位置</span></span><br><span class="line">            U.putOrderedObject(a, j, task);<span class="comment">//任务入列</span></span><br><span class="line">            U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);<span class="comment">//更新push slot</span></span><br><span class="line">            U.putIntVolatile(q, QLOCK, <span class="number">0</span>);<span class="comment">//解除锁定</span></span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">                signalWork(ws, q);<span class="comment">//任务数小于1时尝试创建或激活一个工作线程</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//解除锁定</span></span><br><span class="line">    &#125;</span><br><span class="line">    externalSubmit(task);<span class="comment">//初始化workQueues及相关属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先说明一下externalPush和externalSubmit两个方法的联系: 它们的作用都是把任务放到队列中等待执行。不同的是，externalSubmit可以说是完整版的externalPush，在任务首次提交时，需要初始化workQueues及其他相关属性，这个初始化操作就是externalSubmit来完成的；而后再向池中提交的任务都是通过简化版的externalSubmit-externalPush来完成。</p>
<p>externalPush的执行流程很简单: 首先找到一个随机偶数槽位的 workQueue，然后把任务放入这个 workQueue 的任务数组中，并更新top位。如果队列的剩余任务数小于1，则尝试创建或激活一个工作线程来运行任务(防止在externalSubmit初始化时发生异常导致工作线程创建失败)。</p>
<h4 id="externalSubmit-ForkJoinTask-lt-gt-task"><a href="#externalSubmit-ForkJoinTask-lt-gt-task" class="headerlink" title="externalSubmit(ForkJoinTask&lt;?&gt; task)"></a>externalSubmit(ForkJoinTask&lt;?&gt; task)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//任务提交</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">externalSubmit</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;</span><br><span class="line">    <span class="comment">//初始化调用线程的探针值，用于计算WorkQueue索引</span></span><br><span class="line">    <span class="type">int</span> r;                                    <span class="comment">// initialize caller&#x27;s probe</span></span><br><span class="line">    <span class="keyword">if</span> ((r = ThreadLocalRandom.getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">        ThreadLocalRandom.localInit();</span><br><span class="line">        r = ThreadLocalRandom.getProbe();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        WorkQueue[] ws;</span><br><span class="line">        WorkQueue q;</span><br><span class="line">        <span class="type">int</span> rs, m, k;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">move</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> ((rs = runState) &lt; <span class="number">0</span>) &#123;<span class="comment">// 池已关闭</span></span><br><span class="line">            tryTerminate(<span class="literal">false</span>, <span class="literal">false</span>);     <span class="comment">// help terminate</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化workQueues</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span> ||     <span class="comment">// initialize</span></span><br><span class="line">                ((ws = workQueues) == <span class="literal">null</span> || (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ns</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            rs = lockRunState();<span class="comment">//锁定runState</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//初始化</span></span><br><span class="line">                <span class="keyword">if</span> ((rs &amp; STARTED) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//初始化stealCounter</span></span><br><span class="line">                    U.compareAndSwapObject(<span class="built_in">this</span>, STEALCOUNTER, <span class="literal">null</span>,</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">AtomicLong</span>());</span><br><span class="line">                    <span class="comment">//创建workQueues，容量为2的幂次方</span></span><br><span class="line">                    <span class="comment">// create workQueues array with size a power of two</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> config &amp; SMASK; <span class="comment">// ensure at least 2 slots</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (p &gt; <span class="number">1</span>) ? p - <span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">                    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">                    n = (n + <span class="number">1</span>) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                    workQueues = <span class="keyword">new</span> <span class="title class_">WorkQueue</span>[n];</span><br><span class="line">                    ns = STARTED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                unlockRunState(rs, (rs &amp; ~RSLOCK) | ns);<span class="comment">//解锁并更新runState</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((q = ws[k = r &amp; m &amp; SQMASK]) != <span class="literal">null</span>) &#123;<span class="comment">//获取随机偶数槽位的workQueue</span></span><br><span class="line">            <span class="keyword">if</span> (q.qlock == <span class="number">0</span> &amp;&amp; U.compareAndSwapInt(q, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//锁定 workQueue</span></span><br><span class="line">                ForkJoinTask&lt;?&gt;[] a = q.array;<span class="comment">//当前workQueue的全部任务</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> q.top;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">submitted</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// initial submission or resizing</span></span><br><span class="line">                <span class="keyword">try</span> &#123;                      <span class="comment">// locked version of push</span></span><br><span class="line">                    <span class="keyword">if</span> ((a != <span class="literal">null</span> &amp;&amp; a.length &gt; s + <span class="number">1</span> - q.base) ||</span><br><span class="line">                            (a = q.growArray()) != <span class="literal">null</span>) &#123;<span class="comment">//扩容</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> (((a.length - <span class="number">1</span>) &amp; s) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                        U.putOrderedObject(a, j, task);<span class="comment">//放入给定任务</span></span><br><span class="line">                        U.putOrderedInt(q, QTOP, s + <span class="number">1</span>);<span class="comment">//修改push slot</span></span><br><span class="line">                        submitted = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    U.compareAndSwapInt(q, QLOCK, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//解除锁定</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (submitted) &#123;<span class="comment">//任务提交成功，创建或激活工作线程</span></span><br><span class="line">                    signalWork(ws, q);<span class="comment">//创建或激活一个工作线程来运行任务</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            move = <span class="literal">true</span>;                   <span class="comment">// move on failure 操作失败，重新获取探针值</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((rs = runState) &amp; RSLOCK) == <span class="number">0</span>) &#123; <span class="comment">// create new queue</span></span><br><span class="line">            q = <span class="keyword">new</span> <span class="title class_">WorkQueue</span>(<span class="built_in">this</span>, <span class="literal">null</span>);</span><br><span class="line">            q.hint = r;</span><br><span class="line">            q.config = k | SHARED_QUEUE;</span><br><span class="line">            q.scanState = INACTIVE;</span><br><span class="line">            rs = lockRunState();           <span class="comment">// publish index</span></span><br><span class="line">            <span class="keyword">if</span> (rs &gt; <span class="number">0</span> &amp;&amp; (ws = workQueues) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                    k &lt; ws.length &amp;&amp; ws[k] == <span class="literal">null</span>)</span><br><span class="line">                ws[k] = q;                 <span class="comment">// 更新索引k位值的workQueue</span></span><br><span class="line">            <span class="comment">//else terminated</span></span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            move = <span class="literal">true</span>;                   <span class="comment">// move if busy</span></span><br><span class="line">        <span class="keyword">if</span> (move)</span><br><span class="line">            r = ThreadLocalRandom.advanceProbe(r);<span class="comment">//重新获取线程探针值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: externalSubmit是externalPush的完整版本，主要用于第一次提交任务时初始化workQueues及相关属性，并且提交给定任务到队列中。具体执行步骤如下:</p>
<ul>
<li>如果池为终止状态(runState&lt;0)，调用tryTerminate来终止线程池，并抛出任务拒绝异常；</li>
<li>如果尚未初始化，就为 FJP 执行初始化操作: 初始化stealCounter、创建workerQueues，然后继续自旋；</li>
<li>初始化完成后，执行在externalPush中相同的操作: 获取 workQueue，放入指定任务。任务提交成功后调用signalWork方法创建或激活线程；</li>
<li>如果在步骤3中获取到的 workQueue 为null，会在这一步中创建一个 workQueue，创建成功继续自旋执行第三步操作；</li>
<li>如果非上述情况，或者有线程争用资源导致获取锁失败，就重新获取线程探针值继续自旋。</li>
</ul>
<h4 id="signalWork-WorkQueue-ws-WorkQueue-q"><a href="#signalWork-WorkQueue-ws-WorkQueue-q" class="headerlink" title="signalWork(WorkQueue[] ws, WorkQueue q)"></a>signalWork(WorkQueue[] ws, WorkQueue q)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signalWork</span><span class="params">(WorkQueue[] ws, WorkQueue q)</span> &#123;</span><br><span class="line">    <span class="type">long</span> c;</span><br><span class="line">    <span class="type">int</span> sp, i;</span><br><span class="line">    WorkQueue v;</span><br><span class="line">    Thread p;</span><br><span class="line">    <span class="keyword">while</span> ((c = ctl) &lt; <span class="number">0L</span>) &#123;                       <span class="comment">// too few active</span></span><br><span class="line">        <span class="keyword">if</span> ((sp = (<span class="type">int</span>) c) == <span class="number">0</span>) &#123;                  <span class="comment">// no idle workers</span></span><br><span class="line">            <span class="keyword">if</span> ((c &amp; ADD_WORKER) != <span class="number">0L</span>)            <span class="comment">// too few workers</span></span><br><span class="line">                tryAddWorker(c);<span class="comment">//工作线程太少，添加新的工作线程</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ws == <span class="literal">null</span>)                            <span class="comment">// unstarted/terminated</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws.length &lt;= (i = sp &amp; SMASK))         <span class="comment">// terminated</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ((v = ws[i]) == <span class="literal">null</span>)                   <span class="comment">// terminating</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//计算ctl，加上版本戳SS_SEQ避免ABA问题</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">vs</span> <span class="operator">=</span> (sp + SS_SEQ) &amp; ~INACTIVE;        <span class="comment">// next scanState</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> sp - v.scanState;                  <span class="comment">// screen CAS</span></span><br><span class="line">        <span class="comment">//计算活跃线程数(高32位)并更新为下一个栈顶的scanState(低32位)</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">nc</span> <span class="operator">=</span> (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line">        <span class="keyword">if</span> (d == <span class="number">0</span> &amp;&amp; U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">            v.scanState = vs;                      <span class="comment">// activate v</span></span><br><span class="line">            <span class="keyword">if</span> ((p = v.parker) != <span class="literal">null</span>)</span><br><span class="line">                U.unpark(p);<span class="comment">//唤醒阻塞线程</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="literal">null</span> &amp;&amp; q.base == q.top)          <span class="comment">// no more work</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: 新建或唤醒一个工作线程，在externalPush、externalSubmit、workQueue.push、scan中调用。如果还有空闲线程，则尝试唤醒索引到的 WorkQueue 的parker线程；如果工作线程过少((ctl &amp; ADD_WORKER) !&#x3D; 0L)，则调用tryAddWorker添加一个新的工作线程。</p>
<h4 id="tryAddWorker-long-c"><a href="#tryAddWorker-long-c" class="headerlink" title="tryAddWorker(long c)"></a>tryAddWorker(long c)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">tryAddWorker</span><span class="params">(<span class="type">long</span> c)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">add</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">nc</span> <span class="operator">=</span> ((AC_MASK &amp; (c + AC_UNIT)) |</span><br><span class="line">                   (TC_MASK &amp; (c + TC_UNIT)));</span><br><span class="line">        <span class="keyword">if</span> (ctl == c) &#123;</span><br><span class="line">            <span class="type">int</span> rs, stop;                 <span class="comment">// check if terminating</span></span><br><span class="line">            <span class="keyword">if</span> ((stop = (rs = lockRunState()) &amp; STOP) == <span class="number">0</span>)</span><br><span class="line">                add = U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, nc);</span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);<span class="comment">//释放锁</span></span><br><span class="line">            <span class="keyword">if</span> (stop != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (add) &#123;</span><br><span class="line">                createWorker();<span class="comment">//创建工作线程</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (((c = ctl) &amp; ADD_WORKER) != <span class="number">0L</span> &amp;&amp; (<span class="type">int</span>)c == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: 尝试添加一个新的工作线程，首先更新ctl中的工作线程数，然后调用createWorker()创建工作线程。</p>
<h4 id="createWorker"><a href="#createWorker" class="headerlink" title="createWorker()"></a>createWorker()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">createWorker</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">ForkJoinWorkerThreadFactory</span> <span class="variable">fac</span> <span class="operator">=</span> factory;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ForkJoinWorkerThread</span> <span class="variable">wt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fac != <span class="literal">null</span> &amp;&amp; (wt = fac.newThread(<span class="built_in">this</span>)) != <span class="literal">null</span>) &#123;</span><br><span class="line">            wt.start();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">        ex = rex;</span><br><span class="line">    &#125;</span><br><span class="line">    deregisterWorker(wt, ex);<span class="comment">//线程创建失败处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: createWorker首先通过线程工厂创一个新的ForkJoinWorkerThread，然后启动这个工作线程(wt.start())。如果期间发生异常，调用deregisterWorker处理线程创建失败的逻辑(deregisterWorker在后面再详细说明)。</p>
<p>ForkJoinWorkerThread 的构造函数如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="title function_">ForkJoinWorkerThread</span><span class="params">(ForkJoinPool pool)</span> &#123;</span><br><span class="line">    <span class="comment">// Use a placeholder until a useful name can be set in registerWorker</span></span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;aForkJoinWorkerThread&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.pool = pool;</span><br><span class="line">    <span class="built_in">this</span>.workQueue = pool.registerWorker(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 ForkJoinWorkerThread 在构造时首先调用父类 Thread 的方法，然后为工作线程注册pool和workQueue，而workQueue的注册任务由ForkJoinPool.registerWorker来完成。</p>
<h4 id="registerWorker"><a href="#registerWorker" class="headerlink" title="registerWorker()"></a>registerWorker()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> WorkQueue <span class="title function_">registerWorker</span><span class="params">(ForkJoinWorkerThread wt)</span> &#123;</span><br><span class="line">    UncaughtExceptionHandler handler;</span><br><span class="line">    <span class="comment">//设置为守护线程</span></span><br><span class="line">    wt.setDaemon(<span class="literal">true</span>);                           <span class="comment">// configure thread</span></span><br><span class="line">    <span class="keyword">if</span> ((handler = ueh) != <span class="literal">null</span>)</span><br><span class="line">        wt.setUncaughtExceptionHandler(handler);</span><br><span class="line">    <span class="type">WorkQueue</span> <span class="variable">w</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WorkQueue</span>(<span class="built_in">this</span>, wt);<span class="comment">//构造新的WorkQueue</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;                                    <span class="comment">// assign a pool index</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">mode</span> <span class="operator">=</span> config &amp; MODE_MASK;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> lockRunState();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        WorkQueue[] ws;</span><br><span class="line">        <span class="type">int</span> n;                    <span class="comment">// skip if no array</span></span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="literal">null</span> &amp;&amp; (n = ws.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//生成新建WorkQueue的索引</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> indexSeed += SEED_INCREMENT;  <span class="comment">// unlikely to collide</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> n - <span class="number">1</span>;</span><br><span class="line">            i = ((s &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m;               <span class="comment">// Worker任务放在奇数索引位 odd-numbered indices</span></span><br><span class="line">            <span class="keyword">if</span> (ws[i] != <span class="literal">null</span>) &#123;                  <span class="comment">// collision 已存在，重新计算索引位</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">probes</span> <span class="operator">=</span> <span class="number">0</span>;                   <span class="comment">// step by approx half n</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> (n &lt;= <span class="number">4</span>) ? <span class="number">2</span> : ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; EVENMASK) + <span class="number">2</span>;</span><br><span class="line">                <span class="comment">//查找可用的索引位</span></span><br><span class="line">                <span class="keyword">while</span> (ws[i = (i + step) &amp; m] != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (++probes &gt;= n) &#123;<span class="comment">//所有索引位都被占用，对workQueues进行扩容</span></span><br><span class="line">                        workQueues = ws = Arrays.copyOf(ws, n &lt;&lt;= <span class="number">1</span>);<span class="comment">//workQueues 扩容</span></span><br><span class="line">                        m = n - <span class="number">1</span>;</span><br><span class="line">                        probes = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            w.hint = s;                           <span class="comment">// use as random seed</span></span><br><span class="line">            w.config = i | mode;</span><br><span class="line">            w.scanState = i;                      <span class="comment">// publication fence</span></span><br><span class="line">            ws[i] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    wt.setName(workerNamePrefix.concat(Integer.toString(i &gt;&gt;&gt; <span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">return</span> w;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: registerWorker是 ForkJoinWorkerThread 构造器的回调函数，用于创建和记录工作线程的 WorkQueue。比较简单，就不多赘述了。注意在此为工作线程创建的 WorkQueue 是放在奇数索引的(代码行: i &#x3D; ((s &lt;&lt; 1) | 1) &amp; m;)</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>OK，外部任务的提交流程就先讲到这里。在createWorker()中启动工作线程后(wt.start())，当为线程分配到CPU执行时间片之后会运行 ForkJoinWorkerThread 的run方法开启线程来执行任务。工作线程执行任务的流程我们在讲完内部任务提交之后会统一讲解。</p>
<h3 id="执行流程-子任务-Worker-task-提交"><a href="#执行流程-子任务-Worker-task-提交" class="headerlink" title="执行流程: 子任务(Worker task)提交"></a>执行流程: 子任务(Worker task)提交</h3><p>子任务的提交相对比较简单，由任务的fork()方法完成。通过上面的流程图可以看到任务被分割(fork)之后调用了ForkJoinPool.WorkQueue.push()方法直接把任务放到队列中等待被执行。</p>
<h4 id="ForkJoinTask-fork"><a href="#ForkJoinTask-fork" class="headerlink" title="ForkJoinTask.fork()"></a>ForkJoinTask.fork()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ForkJoinTask&lt;V&gt; <span class="title function_">fork</span><span class="params">()</span> &#123;</span><br><span class="line">    Thread t;</span><br><span class="line">    <span class="keyword">if</span> ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread)</span><br><span class="line">        ((ForkJoinWorkerThread)t).workQueue.push(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ForkJoinPool.common.externalPush(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: 如果当前线程是 Worker 线程，说明当前任务是fork分割的子任务，通过ForkJoinPool.workQueue.push()方法直接把任务放到自己的等待队列中；否则调用ForkJoinPool.externalPush()提交到一个随机的等待队列中(外部任务)。</p>
<h4 id="ForkJoinPool-WorkQueue-push"><a href="#ForkJoinPool-WorkQueue-push" class="headerlink" title="ForkJoinPool.WorkQueue.push()"></a>ForkJoinPool.WorkQueue.push()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a;</span><br><span class="line">    ForkJoinPool p;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> base, s = top, n;</span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="literal">null</span>) &#123;    <span class="comment">// ignore if queue removed</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> a.length - <span class="number">1</span>;     <span class="comment">// fenced write for task visibility</span></span><br><span class="line">        U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);</span><br><span class="line">        U.putOrderedInt(<span class="built_in">this</span>, QTOP, s + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> ((n = s - b) &lt;= <span class="number">1</span>) &#123;<span class="comment">//首次提交，创建或唤醒一个工作线程</span></span><br><span class="line">            <span class="keyword">if</span> ((p = pool) != <span class="literal">null</span>)</span><br><span class="line">                p.signalWork(p.workQueues, <span class="built_in">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= m)</span><br><span class="line">            growArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: 首先把任务放入等待队列并更新top位；如果当前 WorkQueue 为新建的等待队列(top-base&lt;&#x3D;1)，则调用signalWork方法为当前 WorkQueue 新建或唤醒一个工作线程；如果 WorkQueue 中的任务数组容量过小，则调用growArray()方法对其进行两倍扩容，growArray()方法源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ForkJoinTask&lt;?&gt;[] growArray() &#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] oldA = array;<span class="comment">//获取内部任务列表</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> oldA != <span class="literal">null</span> ? oldA.length &lt;&lt; <span class="number">1</span> : INITIAL_QUEUE_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (size &gt; MAXIMUM_QUEUE_CAPACITY)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(<span class="string">&quot;Queue capacity exceeded&quot;</span>);</span><br><span class="line">    <span class="type">int</span> oldMask, t, b;</span><br><span class="line">    <span class="comment">//新建一个两倍容量的任务数组</span></span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a = array = <span class="keyword">new</span> <span class="title class_">ForkJoinTask</span>&lt;?&gt;[size];</span><br><span class="line">    <span class="keyword">if</span> (oldA != <span class="literal">null</span> &amp;&amp; (oldMask = oldA.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (t = top) - (b = base) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> size - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从老数组中拿出数据，放到新的数组中</span></span><br><span class="line">        <span class="keyword">do</span> &#123; <span class="comment">// emulate poll from old array, push to new array</span></span><br><span class="line">            ForkJoinTask&lt;?&gt; x;</span><br><span class="line">            <span class="type">int</span> <span class="variable">oldj</span> <span class="operator">=</span> ((b &amp; oldMask) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> ((b &amp; mask) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">            x = (ForkJoinTask&lt;?&gt;) U.getObjectVolatile(oldA, oldj);</span><br><span class="line">            <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                    U.compareAndSwapObject(oldA, oldj, x, <span class="literal">null</span>))</span><br><span class="line">                U.putObjectVolatile(a, j, x);</span><br><span class="line">        &#125; <span class="keyword">while</span> (++b != t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>到此，两种任务的提交流程都已经解析完毕，下一节我们来一起看看任务提交之后是如何被运行的。</p>
<h3 id="执行流程-任务执行"><a href="#执行流程-任务执行" class="headerlink" title="执行流程: 任务执行"></a>执行流程: 任务执行</h3><p>回到我们开始时的流程图，在ForkJoinPool .createWorker()方法中创建工作线程后，会启动工作线程，系统为工作线程分配到CPU执行时间片之后会执行 ForkJoinWorkerThread 的run()方法正式开始执行任务。</p>
<h4 id="ForkJoinWorkerThread-run"><a href="#ForkJoinWorkerThread-run" class="headerlink" title="ForkJoinWorkerThread.run()"></a>ForkJoinWorkerThread.run()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (workQueue.array == <span class="literal">null</span>) &#123; <span class="comment">// only run once</span></span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            onStart();<span class="comment">//钩子方法，可自定义扩展</span></span><br><span class="line">            pool.runWorker(workQueue);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            exception = ex;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                onTermination(exception);<span class="comment">//钩子方法，可自定义扩展</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">                <span class="keyword">if</span> (exception == <span class="literal">null</span>)</span><br><span class="line">                    exception = ex;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                pool.deregisterWorker(<span class="built_in">this</span>, exception);<span class="comment">//处理异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: 方法很简单，在工作线程运行前后会调用自定义钩子函数(onStart和onTermination)，任务的运行则是调用了ForkJoinPool.runWorker()。如果全部任务执行完毕或者期间遭遇异常，则通过ForkJoinPool.deregisterWorker关闭工作线程并处理异常信息(deregisterWorker方法我们后面会详细讲解)。</p>
<h4 id="ForkJoinPool-runWorker-WorkQueue-w"><a href="#ForkJoinPool-runWorker-WorkQueue-w" class="headerlink" title="ForkJoinPool.runWorker(WorkQueue w)"></a>ForkJoinPool.runWorker(WorkQueue w)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runWorker</span><span class="params">(WorkQueue w)</span> &#123;</span><br><span class="line">    w.growArray();                   <span class="comment">// allocate queue</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">seed</span> <span class="operator">=</span> w.hint;               <span class="comment">// initially holds randomization hint</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> (seed == <span class="number">0</span>) ? <span class="number">1</span> : seed;  <span class="comment">// avoid 0 for xorShift</span></span><br><span class="line">    <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t; ; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((t = scan(w, r)) != <span class="literal">null</span>)<span class="comment">//扫描任务执行</span></span><br><span class="line">            w.runTask(t);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!awaitWork(w, r))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        r ^= r &lt;&lt; <span class="number">13</span>;</span><br><span class="line">        r ^= r &gt;&gt;&gt; <span class="number">17</span>;</span><br><span class="line">        r ^= r &lt;&lt; <span class="number">5</span>; <span class="comment">// xorshift</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: runWorker是 ForkJoinWorkerThread 的主运行方法，用来依次执行当前工作线程中的任务。函数流程很简单: 调用scan方法依次获取任务，然后调用WorkQueue .runTask运行任务；如果未扫描到任务，则调用awaitWork等待，直到工作线程&#x2F;线程池终止或等待超时。</p>
<h4 id="ForkJoinPool-scan-WorkQueue-w-int-r"><a href="#ForkJoinPool-scan-WorkQueue-w-int-r" class="headerlink" title="ForkJoinPool.scan(WorkQueue w, int r)"></a>ForkJoinPool.scan(WorkQueue w, int r)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ForkJoinTask&lt;?&gt; scan(WorkQueue w, <span class="type">int</span> r) &#123;</span><br><span class="line">    WorkQueue[] ws;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="literal">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt; <span class="number">0</span> &amp;&amp; w != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ss</span> <span class="operator">=</span> w.scanState;                     <span class="comment">// initially non-negative</span></span><br><span class="line">        <span class="comment">//初始扫描起点，自旋扫描</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">origin</span> <span class="operator">=</span> r &amp; m, k = origin, oldSum = <span class="number">0</span>, checkSum = <span class="number">0</span>; ; ) &#123;</span><br><span class="line">            WorkQueue q;</span><br><span class="line">            ForkJoinTask&lt;?&gt;[] a;</span><br><span class="line">            ForkJoinTask&lt;?&gt; t;</span><br><span class="line">            <span class="type">int</span> b, n;</span><br><span class="line">            <span class="type">long</span> c;</span><br><span class="line">            <span class="keyword">if</span> ((q = ws[k]) != <span class="literal">null</span>) &#123;<span class="comment">//获取workQueue</span></span><br><span class="line">                <span class="keyword">if</span> ((n = (b = q.base) - q.top) &lt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                        (a = q.array) != <span class="literal">null</span>) &#123;      <span class="comment">// non-empty</span></span><br><span class="line">                    <span class="comment">//计算偏移量</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;</span><br><span class="line">                    <span class="keyword">if</span> ((t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                            U.getObjectVolatile(a, i))) != <span class="literal">null</span> &amp;&amp; <span class="comment">//取base位置任务</span></span><br><span class="line">                            q.base == b) &#123;<span class="comment">//stable</span></span><br><span class="line">                        <span class="keyword">if</span> (ss &gt;= <span class="number">0</span>) &#123;  <span class="comment">//scanning</span></span><br><span class="line">                            <span class="keyword">if</span> (U.compareAndSwapObject(a, i, t, <span class="literal">null</span>)) &#123;<span class="comment">//</span></span><br><span class="line">                                q.base = b + <span class="number">1</span>;<span class="comment">//更新base位</span></span><br><span class="line">                                <span class="keyword">if</span> (n &lt; -<span class="number">1</span>)       <span class="comment">// signal others</span></span><br><span class="line">                                    signalWork(ws, q);<span class="comment">//创建或唤醒工作线程来运行任务</span></span><br><span class="line">                                <span class="keyword">return</span> t;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldSum == <span class="number">0</span> &amp;&amp;   <span class="comment">// try to activate 尝试激活工作线程</span></span><br><span class="line">                                w.scanState &lt; <span class="number">0</span>)</span><br><span class="line">                            tryRelease(c = ctl, ws[m &amp; (<span class="type">int</span>) c], AC_UNIT);<span class="comment">//唤醒栈顶工作线程</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//base位置任务为空或base位置偏移，随机移位重新扫描</span></span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span>)                   <span class="comment">// refresh</span></span><br><span class="line">                        ss = w.scanState;</span><br><span class="line">                    r ^= r &lt;&lt; <span class="number">1</span>;</span><br><span class="line">                    r ^= r &gt;&gt;&gt; <span class="number">3</span>;</span><br><span class="line">                    r ^= r &lt;&lt; <span class="number">10</span>;</span><br><span class="line">                    origin = k = r &amp; m;           <span class="comment">// move and rescan</span></span><br><span class="line">                    oldSum = checkSum = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                checkSum += b;<span class="comment">//队列任务为空，记录base位</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新索引k 继续向后查找</span></span><br><span class="line">            <span class="keyword">if</span> ((k = (k + <span class="number">1</span>) &amp; m) == origin) &#123;    <span class="comment">// continue until stable</span></span><br><span class="line">                <span class="comment">//运行到这里说明已经扫描了全部的 workQueues，但并未扫描到任务</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((ss &gt;= <span class="number">0</span> || (ss == (ss = w.scanState))) &amp;&amp;</span><br><span class="line">                        oldSum == (oldSum = checkSum)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ss &lt; <span class="number">0</span> || w.qlock &lt; <span class="number">0</span>)    <span class="comment">// already inactive</span></span><br><span class="line">                        <span class="keyword">break</span>;<span class="comment">// 已经被灭活或终止,跳出循环</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//对当前WorkQueue进行灭活操作</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">ns</span> <span class="operator">=</span> ss | INACTIVE;       <span class="comment">// try to inactivate</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">nc</span> <span class="operator">=</span> ((SP_MASK &amp; ns) |</span><br><span class="line">                            (UC_MASK &amp; ((c = ctl) - AC_UNIT)));<span class="comment">//计算ctl为INACTIVE状态并减少活跃线程数</span></span><br><span class="line">                    w.stackPred = (<span class="type">int</span>) c;         <span class="comment">// hold prev stack top</span></span><br><span class="line">                    U.putInt(w, QSCANSTATE, ns);<span class="comment">//修改scanState为inactive状态</span></span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, nc))<span class="comment">//更新scanState为灭活状态</span></span><br><span class="line">                        ss = ns;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        w.scanState = ss;         <span class="comment">// back out</span></span><br><span class="line">                &#125;</span><br><span class="line">                checkSum = <span class="number">0</span>;<span class="comment">//重置checkSum，继续循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: 扫描并尝试偷取一个任务。使用w.hint进行随机索引 WorkQueue，也就是说并不一定会执行当前 WorkQueue 中的任务，而是偷取别的Worker的任务来执行。</p>
<p>函数的大概执行流程如下:</p>
<ul>
<li><p>取随机位置的一个 WorkQueue；</p>
</li>
<li><p>获取base位的 ForkJoinTask，成功取到后更新base位并返回任务；如果取到的 WorkQueue 中任务数大于1，则调用signalWork创建或唤醒其他工作线程；</p>
</li>
<li><p>如果当前工作线程处于不活跃状态(INACTIVE)，则调用tryRelease尝试唤醒栈顶工作线程来执行。</p>
<p>tryRelease源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">long</span> c, WorkQueue v, <span class="type">long</span> inc)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sp</span> <span class="operator">=</span> (<span class="type">int</span>) c, vs = (sp + SS_SEQ) &amp; ~INACTIVE;</span><br><span class="line">    Thread p;</span><br><span class="line">    <span class="comment">//ctl低32位等于scanState，说明可以唤醒parker线程</span></span><br><span class="line">    <span class="keyword">if</span> (v != <span class="literal">null</span> &amp;&amp; v.scanState == sp) &#123;          <span class="comment">// v is at top of stack</span></span><br><span class="line">        <span class="comment">//计算活跃线程数(高32位)并更新为下一个栈顶的scanState(低32位)</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">nc</span> <span class="operator">=</span> (UC_MASK &amp; (c + inc)) | (SP_MASK &amp; v.stackPred);</span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, nc)) &#123;</span><br><span class="line">            v.scanState = vs;</span><br><span class="line">            <span class="keyword">if</span> ((p = v.parker) != <span class="literal">null</span>)</span><br><span class="line">                U.unpark(p);<span class="comment">//唤醒线程</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果base位任务为空或发生偏移，则对索引位进行随机移位，然后重新扫描；</p>
</li>
<li><p>如果扫描整个workQueues之后没有获取到任务，则设置当前工作线程为INACTIVE状态；然后重置checkSum，再次扫描一圈之后如果还没有任务则跳出循环返回null。</p>
</li>
</ul>
<h4 id="ForkJoinPool-awaitWork-WorkQueue-w-int-r"><a href="#ForkJoinPool-awaitWork-WorkQueue-w-int-r" class="headerlink" title="ForkJoinPool.awaitWork(WorkQueue w, int r)"></a>ForkJoinPool.awaitWork(WorkQueue w, int r)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">awaitWork</span><span class="params">(WorkQueue w, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="literal">null</span> || w.qlock &lt; <span class="number">0</span>)                 <span class="comment">// w is terminating</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">pred</span> <span class="operator">=</span> w.stackPred, spins = SPINS, ss; ; ) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ss = w.scanState) &gt;= <span class="number">0</span>)<span class="comment">//正在扫描，跳出循环</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (spins &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            r ^= r &lt;&lt; <span class="number">6</span>;</span><br><span class="line">            r ^= r &gt;&gt;&gt; <span class="number">21</span>;</span><br><span class="line">            r ^= r &lt;&lt; <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">if</span> (r &gt;= <span class="number">0</span> &amp;&amp; --spins == <span class="number">0</span>) &#123;         <span class="comment">// randomize spins</span></span><br><span class="line">                WorkQueue v;</span><br><span class="line">                WorkQueue[] ws;</span><br><span class="line">                <span class="type">int</span> s, j;</span><br><span class="line">                AtomicLong sc;</span><br><span class="line">                <span class="keyword">if</span> (pred != <span class="number">0</span> &amp;&amp; (ws = workQueues) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">                        (j = pred &amp; SMASK) &lt; ws.length &amp;&amp;</span><br><span class="line">                        (v = ws[j]) != <span class="literal">null</span> &amp;&amp;        <span class="comment">// see if pred parking</span></span><br><span class="line">                        (v.parker == <span class="literal">null</span> || v.scanState &gt;= <span class="number">0</span>))</span><br><span class="line">                    spins = SPINS;                <span class="comment">// continue spinning</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (w.qlock &lt; <span class="number">0</span>)                     <span class="comment">// 当前workQueue已经终止，返回false recheck after spins</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!Thread.interrupted()) &#123;<span class="comment">//判断线程是否被中断，并清除中断状态</span></span><br><span class="line">            <span class="type">long</span> c, prevctl, parkTime, deadline;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ac</span> <span class="operator">=</span> (<span class="type">int</span>) ((c = ctl) &gt;&gt; AC_SHIFT) + (config &amp; SMASK);<span class="comment">//活跃线程数</span></span><br><span class="line">            <span class="keyword">if</span> ((ac &lt;= <span class="number">0</span> &amp;&amp; tryTerminate(<span class="literal">false</span>, <span class="literal">false</span>)) || <span class="comment">//无active线程，尝试终止</span></span><br><span class="line">                    (runState &amp; STOP) != <span class="number">0</span>)           <span class="comment">// pool terminating</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (ac &lt;= <span class="number">0</span> &amp;&amp; ss == (<span class="type">int</span>) c) &#123;        <span class="comment">// is last waiter</span></span><br><span class="line">                <span class="comment">//计算活跃线程数(高32位)并更新为下一个栈顶的scanState(低32位)</span></span><br><span class="line">                prevctl = (UC_MASK &amp; (c + AC_UNIT)) | (SP_MASK &amp; pred);</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> (<span class="type">short</span>) (c &gt;&gt;&gt; TC_SHIFT);  <span class="comment">// shrink excess spares</span></span><br><span class="line">                <span class="keyword">if</span> (t &gt; <span class="number">2</span> &amp;&amp; U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, prevctl))<span class="comment">//总线程过量</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;                 <span class="comment">// else use timed wait</span></span><br><span class="line">                <span class="comment">//计算空闲超时时间</span></span><br><span class="line">                parkTime = IDLE_TIMEOUT * ((t &gt;= <span class="number">0</span>) ? <span class="number">1</span> : <span class="number">1</span> - t);</span><br><span class="line">                deadline = System.nanoTime() + parkTime - TIMEOUT_SLOP;</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                prevctl = parkTime = deadline = <span class="number">0L</span>;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">wt</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="built_in">this</span>);   <span class="comment">// emulate LockSupport</span></span><br><span class="line">            w.parker = wt;<span class="comment">//设置parker，准备阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (w.scanState &lt; <span class="number">0</span> &amp;&amp; ctl == c)      <span class="comment">// recheck before park</span></span><br><span class="line">                U.park(<span class="literal">false</span>, parkTime);<span class="comment">//阻塞指定的时间</span></span><br><span class="line"></span><br><span class="line">            U.putOrderedObject(w, QPARKER, <span class="literal">null</span>);</span><br><span class="line">            U.putObject(wt, PARKBLOCKER, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (w.scanState &gt;= <span class="number">0</span>)<span class="comment">//正在扫描，说明等到任务，跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (parkTime != <span class="number">0L</span> &amp;&amp; ctl == c &amp;&amp;</span><br><span class="line">                    deadline - System.nanoTime() &lt;= <span class="number">0L</span> &amp;&amp;</span><br><span class="line">                    U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, prevctl))<span class="comment">//未等到任务，更新ctl，返回false</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;                     <span class="comment">// shrink pool</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: 回到runWorker方法，如果scan方法未扫描到任务，会调用awaitWork等待获取任务。函数的具体执行流程大家看源码，这里简单说一下:</p>
<ul>
<li>在等待获取任务期间，如果工作线程或线程池已经终止则直接返回false。如果当前无 active 线程，尝试终止线程池并返回false，如果终止失败并且当前是最后一个等待的 Worker，就阻塞指定的时间(IDLE_TIMEOUT)；等到届期或被唤醒后如果发现自己是scanning(scanState &gt;&#x3D; 0)状态，说明已经等到任务，跳出等待返回true继续 scan，否则的更新ctl并返回false。</li>
</ul>
<h4 id="WorkQueue-runTask"><a href="#WorkQueue-runTask" class="headerlink" title="WorkQueue.runTask()"></a>WorkQueue.runTask()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runTask</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">        scanState &amp;= ~SCANNING; <span class="comment">// mark as busy</span></span><br><span class="line">        (currentSteal = task).doExec();<span class="comment">//更新currentSteal并执行任务</span></span><br><span class="line">        U.putOrderedObject(<span class="built_in">this</span>, QCURRENTSTEAL, <span class="literal">null</span>); <span class="comment">// release for GC</span></span><br><span class="line">        execLocalTasks();<span class="comment">//依次执行本地任务</span></span><br><span class="line">        <span class="type">ForkJoinWorkerThread</span> <span class="variable">thread</span> <span class="operator">=</span> owner;</span><br><span class="line">        <span class="keyword">if</span> (++nsteals &lt; <span class="number">0</span>)      <span class="comment">// collect on overflow</span></span><br><span class="line">            transferStealCount(pool);<span class="comment">//增加偷取任务数</span></span><br><span class="line">        scanState |= SCANNING;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="literal">null</span>)</span><br><span class="line">            thread.afterTopLevelExec();<span class="comment">//执行钩子函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: 在scan方法扫描到任务之后，调用WorkQueue.runTask()来执行获取到的任务，大概流程如下:</p>
<ul>
<li><p>标记scanState为正在执行状态；</p>
</li>
<li><p>更新currentSteal为当前获取到的任务并执行它，任务的执行调用了ForkJoinTask.doExec()方法，源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ForkJoinTask.doExec()</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">doExec</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s; <span class="type">boolean</span> completed;</span><br><span class="line">    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            completed = exec();<span class="comment">//执行我们定义的任务</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable rex) &#123;</span><br><span class="line">            <span class="keyword">return</span> setExceptionalCompletion(rex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (completed)</span><br><span class="line">            s = setCompletion(NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用execLocalTasks依次执行当前WorkerQueue中的任务，源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行并移除所有本地任务</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">execLocalTasks</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> base, m, s;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a = array;</span><br><span class="line">    <span class="keyword">if</span> (b - (s = top - <span class="number">1</span>) &lt;= <span class="number">0</span> &amp;&amp; a != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((config &amp; FIFO_QUEUE) == <span class="number">0</span>) &#123;<span class="comment">//FIFO模式</span></span><br><span class="line">            <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t; ; ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;) U.getAndSetObject</span><br><span class="line">                        (a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, <span class="literal">null</span>)) == <span class="literal">null</span>)<span class="comment">//FIFO执行，取top任务</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                U.putOrderedInt(<span class="built_in">this</span>, QTOP, s);</span><br><span class="line">                t.doExec();<span class="comment">//执行</span></span><br><span class="line">                <span class="keyword">if</span> (base - (s = top - <span class="number">1</span>) &gt; <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            pollAndExecAll();<span class="comment">//LIFO模式执行，取base任务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>更新偷取任务数；</p>
</li>
<li><p>还原scanState并执行钩子函数。</p>
</li>
</ul>
<h4 id="ForkJoinPool-deregisterWorker-ForkJoinWorkerThread-wt-Throwable-ex"><a href="#ForkJoinPool-deregisterWorker-ForkJoinWorkerThread-wt-Throwable-ex" class="headerlink" title="ForkJoinPool.deregisterWorker(ForkJoinWorkerThread wt, Throwable ex)"></a>ForkJoinPool.deregisterWorker(ForkJoinWorkerThread wt, Throwable ex)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">deregisterWorker</span><span class="params">(ForkJoinWorkerThread wt, Throwable ex)</span> &#123;</span><br><span class="line">    <span class="type">WorkQueue</span> <span class="variable">w</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//1.移除workQueue</span></span><br><span class="line">    <span class="keyword">if</span> (wt != <span class="literal">null</span> &amp;&amp; (w = wt.workQueue) != <span class="literal">null</span>) &#123;<span class="comment">//获取ForkJoinWorkerThread的等待队列</span></span><br><span class="line">        WorkQueue[] ws;                           <span class="comment">// remove index from array</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> w.config &amp; SMASK;<span class="comment">//计算workQueue索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rs</span> <span class="operator">=</span> lockRunState();<span class="comment">//获取runState锁和当前池运行状态</span></span><br><span class="line">        <span class="keyword">if</span> ((ws = workQueues) != <span class="literal">null</span> &amp;&amp; ws.length &gt; idx &amp;&amp; ws[idx] == w)</span><br><span class="line">            ws[idx] = <span class="literal">null</span>;<span class="comment">//移除workQueue</span></span><br><span class="line">        unlockRunState(rs, rs &amp; ~RSLOCK);<span class="comment">//解除runState锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.减少CTL数</span></span><br><span class="line">    <span class="type">long</span> c;                                       <span class="comment">// decrement counts</span></span><br><span class="line">    <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (!U.compareAndSwapLong</span><br><span class="line">                 (<span class="built_in">this</span>, CTL, c = ctl, ((AC_MASK &amp; (c - AC_UNIT)) |</span><br><span class="line">                                       (TC_MASK &amp; (c - TC_UNIT)) |</span><br><span class="line">                                       (SP_MASK &amp; c))));</span><br><span class="line">    <span class="comment">//3.处理被移除workQueue内部相关参数</span></span><br><span class="line">    <span class="keyword">if</span> (w != <span class="literal">null</span>) &#123;</span><br><span class="line">        w.qlock = -<span class="number">1</span>;                             <span class="comment">// ensure set</span></span><br><span class="line">        w.transferStealCount(<span class="built_in">this</span>);</span><br><span class="line">        w.cancelAll();                            <span class="comment">// cancel remaining tasks</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.如果线程未终止，替换被移除的workQueue并唤醒内部线程</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;                                    <span class="comment">// possibly replace</span></span><br><span class="line">        WorkQueue[] ws; <span class="type">int</span> m, sp;</span><br><span class="line">        <span class="comment">//尝试终止线程池</span></span><br><span class="line">        <span class="keyword">if</span> (tryTerminate(<span class="literal">false</span>, <span class="literal">false</span>) || w == <span class="literal">null</span> || w.array == <span class="literal">null</span> ||</span><br><span class="line">            (runState &amp; STOP) != <span class="number">0</span> || (ws = workQueues) == <span class="literal">null</span> ||</span><br><span class="line">            (m = ws.length - <span class="number">1</span>) &lt; <span class="number">0</span>)              <span class="comment">// already terminating</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//唤醒被替换的线程，依赖于下一步</span></span><br><span class="line">        <span class="keyword">if</span> ((sp = (<span class="type">int</span>)(c = ctl)) != <span class="number">0</span>) &#123;         <span class="comment">// wake up replacement</span></span><br><span class="line">            <span class="keyword">if</span> (tryRelease(c, ws[sp &amp; m], AC_UNIT))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建工作线程替换</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ex != <span class="literal">null</span> &amp;&amp; (c &amp; ADD_WORKER) != <span class="number">0L</span>) &#123;</span><br><span class="line">            tryAddWorker(c);                      <span class="comment">// create replacement</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>                                      <span class="comment">// don&#x27;t need replacement</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.处理异常</span></span><br><span class="line">    <span class="keyword">if</span> (ex == <span class="literal">null</span>)                               <span class="comment">// help clean on way out</span></span><br><span class="line">        ForkJoinTask.helpExpungeStaleExceptions();</span><br><span class="line">    <span class="keyword">else</span>                                          <span class="comment">// rethrow</span></span><br><span class="line">        ForkJoinTask.rethrow(ex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: deregisterWorker方法用于工作线程运行完毕之后终止线程或处理工作线程异常，主要就是清除已关闭的工作线程或回滚创建线程之前的操作，并把传入的异常抛给 ForkJoinTask 来处理。具体步骤见源码注释。</p>
<h4 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h4><p>本节我们对任务的执行流程进行了说明，后面我们将继续介绍任务的结果获取(join&#x2F;invoke)。</p>
<h3 id="获取任务结果-ForkJoinTask-join-x2F-ForkJoinTask-invoke"><a href="#获取任务结果-ForkJoinTask-join-x2F-ForkJoinTask-invoke" class="headerlink" title="获取任务结果 - ForkJoinTask.join() &#x2F; ForkJoinTask.invoke()"></a>获取任务结果 - ForkJoinTask.join() &#x2F; ForkJoinTask.invoke()</h3><ul>
<li>join() :</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并任务结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">join</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//join, get, quietlyJoin的主实现方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">doJoin</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;</span><br><span class="line">    <span class="keyword">return</span> (s = status) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        (w = (wt = (ForkJoinWorkerThread)t).workQueue).</span><br><span class="line">        tryUnpush(<span class="built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        wt.pool.awaitJoin(w, <span class="built_in">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>invoke() :</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行任务，并等待任务完成并返回结果</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title function_">invoke</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = doInvoke() &amp; DONE_MASK) != NORMAL)</span><br><span class="line">        reportException(s);</span><br><span class="line">    <span class="keyword">return</span> getRawResult();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//invoke, quietlyInvoke的主实现方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">doInvoke</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> s; Thread t; ForkJoinWorkerThread wt;</span><br><span class="line">    <span class="keyword">return</span> (s = doExec()) &lt; <span class="number">0</span> ? s :</span><br><span class="line">        ((t = Thread.currentThread()) <span class="keyword">instanceof</span> ForkJoinWorkerThread) ?</span><br><span class="line">        (wt = (ForkJoinWorkerThread)t).pool.</span><br><span class="line">        awaitJoin(wt.workQueue, <span class="built_in">this</span>, <span class="number">0L</span>) :</span><br><span class="line">        externalAwaitDone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: join()方法一把是在任务fork()之后调用，用来获取(或者叫“合并”)任务的执行结果。</p>
<p>ForkJoinTask的join()和invoke()方法都可以用来获取任务的执行结果(另外还有get方法也是调用了doJoin来获取任务结果，但是会响应运行时异常)，它们对外部提交任务的执行方式一致，都是通过externalAwaitDone方法等待执行结果。不同的是invoke()方法会直接执行当前任务；而join()方法则是在当前任务在队列 top 位时(通过tryUnpush方法判断)才能执行，如果当前任务不在 top 位或者任务执行失败调用ForkJoinPool.awaitJoin方法帮助执行或阻塞当前 join 任务。(所以在官方文档中建议了我们对ForkJoinTask任务的调用顺序，一对 fork-join操作一般按照如下顺序调用: a.fork(); b.fork(); b.join(); a.join();。因为任务 b 是后面进入队列，也就是说它是在栈顶的(top 位)，在它fork()之后直接调用join()就可以直接执行而不会调用ForkJoinPool.awaitJoin方法去等待。)</p>
<p>在这些方法中，join()相对比较全面，所以之后的讲解我们将从join()开始逐步向下分析，首先看一下join()的执行流程:</p>
<p><img src="/2022/12/10/JUC%E7%BA%BF%E7%A8%8B%E6%B1%A0-Fork-Join%E6%A1%86%E6%9E%B6%E8%AF%A6%E8%A7%A3/java-thread-x-forkjoin-6.png"></p>
<p>后面的源码分析中，我们首先讲解比较简单的外部 join 任务(externalAwaitDone)，然后再讲解内部 join 任务(从ForkJoinPool.awaitJoin()开始)。</p>
<h4 id="ForkJoinTask-externalAwaitDone"><a href="#ForkJoinTask-externalAwaitDone" class="headerlink" title="ForkJoinTask.externalAwaitDone()"></a>ForkJoinTask.externalAwaitDone()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">externalAwaitDone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//执行任务</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> ((<span class="built_in">this</span> <span class="keyword">instanceof</span> CountedCompleter) ? <span class="comment">// try helping</span></span><br><span class="line">             ForkJoinPool.common.externalHelpComplete(  <span class="comment">// CountedCompleter任务</span></span><br><span class="line">                 (CountedCompleter&lt;?&gt;)<span class="built_in">this</span>, <span class="number">0</span>) :</span><br><span class="line">             ForkJoinPool.common.tryExternalUnpush(<span class="built_in">this</span>) ? doExec() : <span class="number">0</span>);  <span class="comment">// ForkJoinTask任务</span></span><br><span class="line">    <span class="keyword">if</span> (s &gt;= <span class="number">0</span> &amp;&amp; (s = status) &gt;= <span class="number">0</span>) &#123;<span class="comment">//执行失败，进入等待</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="built_in">this</span>, STATUS, s, s | SIGNAL)) &#123;  <span class="comment">//更新state</span></span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (status &gt;= <span class="number">0</span>) &#123;<span class="comment">//SIGNAL 等待信号</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            wait(<span class="number">0L</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                            interrupted = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((s = status) &gt;= <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (interrupted)</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: 如果当前join为外部调用，则调用此方法执行任务，如果任务执行失败就进入等待。方法本身是很简单的，需要注意的是对不同的任务类型分两种情况:</p>
<ul>
<li><p>如果我们的任务为 CountedCompleter 类型的任务，则调用externalHelpComplete方法来执行任务。</p>
</li>
<li><p>其他类型的 ForkJoinTask 任务调用tryExternalUnpush来执行，源码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为外部提交者提供 tryUnpush 功能(给定任务在top位时弹出任务)</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryExternalUnpush</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;</span><br><span class="line">    WorkQueue[] ws;</span><br><span class="line">    WorkQueue w;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a;</span><br><span class="line">    <span class="type">int</span> m, s;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> ThreadLocalRandom.getProbe();</span><br><span class="line">    <span class="keyword">if</span> ((ws = workQueues) != <span class="literal">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (w = ws[m &amp; r &amp; SQMASK]) != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            (a = w.array) != <span class="literal">null</span> &amp;&amp; (s = w.top) != w.base) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">j</span> <span class="operator">=</span> (((a.length - <span class="number">1</span>) &amp; (s - <span class="number">1</span>)) &lt;&lt; ASHIFT) + ABASE;  <span class="comment">//取top位任务</span></span><br><span class="line">        <span class="keyword">if</span> (U.compareAndSwapInt(w, QLOCK, <span class="number">0</span>, <span class="number">1</span>)) &#123;  <span class="comment">//加锁</span></span><br><span class="line">            <span class="keyword">if</span> (w.top == s &amp;&amp; w.array == a &amp;&amp;</span><br><span class="line">                    U.getObject(a, j) == task &amp;&amp;</span><br><span class="line">                    U.compareAndSwapObject(a, j, task, <span class="literal">null</span>)) &#123;  <span class="comment">//符合条件，弹出</span></span><br><span class="line">                U.putOrderedInt(w, QTOP, s - <span class="number">1</span>);  <span class="comment">//更新top</span></span><br><span class="line">                U.putOrderedInt(w, QLOCK, <span class="number">0</span>); <span class="comment">//解锁，返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            U.compareAndSwapInt(w, QLOCK, <span class="number">1</span>, <span class="number">0</span>);  <span class="comment">//当前任务不在top位，解锁返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>tryExternalUnpush的作用就是判断当前任务是否在top位，如果是则弹出任务，然后在externalAwaitDone中调用doExec()执行任务。</p>
</li>
</ul>
<h4 id="ForkJoinPool-awaitJoin"><a href="#ForkJoinPool-awaitJoin" class="headerlink" title="ForkJoinPool.awaitJoin()"></a>ForkJoinPool.awaitJoin()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">awaitJoin</span><span class="params">(WorkQueue w, ForkJoinTask&lt;?&gt; task, <span class="type">long</span> deadline)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (task != <span class="literal">null</span> &amp;&amp; w != <span class="literal">null</span>) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; prevJoin = w.currentJoin;  <span class="comment">//获取给定Worker的join任务</span></span><br><span class="line">        U.putOrderedObject(w, QCURRENTJOIN, task);  <span class="comment">//把currentJoin替换为给定任务</span></span><br><span class="line">        <span class="comment">//判断是否为CountedCompleter类型的任务</span></span><br><span class="line">        CountedCompleter&lt;?&gt; cc = (task <span class="keyword">instanceof</span> CountedCompleter) ?</span><br><span class="line">                (CountedCompleter&lt;?&gt;) task : <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((s = task.status) &lt; <span class="number">0</span>)  <span class="comment">//已经完成|取消|异常 跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cc != <span class="literal">null</span>)<span class="comment">//CountedCompleter任务由helpComplete来完成join</span></span><br><span class="line">                helpComplete(w, cc, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (w.base == w.top || w.tryRemoveAndExec(task))  <span class="comment">//尝试执行</span></span><br><span class="line">                helpStealer(w, task);  <span class="comment">//队列为空或执行失败，任务可能被偷，帮助偷取者执行该任务</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((s = task.status) &lt; <span class="number">0</span>) <span class="comment">//已经完成|取消|异常，跳出循环</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//计算任务等待时间</span></span><br><span class="line">            <span class="type">long</span> ms, ns;</span><br><span class="line">            <span class="keyword">if</span> (deadline == <span class="number">0L</span>)</span><br><span class="line">                ms = <span class="number">0L</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ns = deadline - System.nanoTime()) &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((ms = TimeUnit.NANOSECONDS.toMillis(ns)) &lt;= <span class="number">0L</span>)</span><br><span class="line">                ms = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tryCompensate(w)) &#123;<span class="comment">//执行补偿操作</span></span><br><span class="line">                task.internalWait(ms);<span class="comment">//补偿执行成功，任务等待指定时间</span></span><br><span class="line">                U.getAndAddLong(<span class="built_in">this</span>, CTL, AC_UNIT);<span class="comment">//更新活跃线程数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        U.putOrderedObject(w, QCURRENTJOIN, prevJoin);<span class="comment">//循环结束，替换为原来的join任务</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: 如果当前 join 任务不在Worker等待队列的top位，或者任务执行失败，调用此方法来帮助执行或阻塞当前 join 的任务。函数执行流程如下:</p>
<ul>
<li><p>由于每次调用awaitJoin都会优先执行当前join的任务，所以首先会更新currentJoin为当前join任务；</p>
</li>
<li><p>进入自旋:</p>
<ul>
<li>首先检查任务是否已经完成(通过task.status &lt; 0判断)，如果给定任务执行完毕|取消|异常 则跳出循环返回执行状态s；</li>
<li>如果是 CountedCompleter 任务类型，调用helpComplete方法来完成join操作(后面笔者会开新篇来专门讲解CountedCompleter，本篇暂时不做详细解析)；</li>
<li>非 CountedCompleter 任务类型调用WorkQueue.tryRemoveAndExec尝试执行任务；</li>
<li>如果给定 WorkQueue 的等待队列为空或任务执行失败，说明任务可能被偷，调用helpStealer帮助偷取者执行任务(也就是说，偷取者帮我执行任务，我去帮偷取者执行它的任务)；</li>
<li>再次判断任务是否执行完毕(task.status &lt; 0)，如果任务执行失败，计算一个等待时间准备进行补偿操作；</li>
<li>调用tryCompensate方法为给定 WorkQueue 尝试执行补偿操作。在执行补偿期间，如果发现 资源争用|池处于unstable状态|当前Worker已终止，则调用ForkJoinTask.internalWait()方法等待指定的时间，任务唤醒之后继续自旋，ForkJoinTask.internalWait()源码如下:</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">internalWait</span><span class="params">(<span class="type">long</span> timeout)</span> &#123;</span><br><span class="line">    <span class="type">int</span> s;</span><br><span class="line">    <span class="keyword">if</span> ((s = status) &gt;= <span class="number">0</span> &amp;&amp; <span class="comment">// force completer to issue notify</span></span><br><span class="line">        U.compareAndSwapInt(<span class="built_in">this</span>, STATUS, s, s | SIGNAL)) &#123;<span class="comment">//更新任务状态为SIGNAL(等待唤醒)</span></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (status &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">try</span> &#123; wait(timeout); &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123; &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>在awaitJoin中，我们总共调用了三个比较复杂的方法: tryRemoveAndExec、helpStealer和tryCompensate，下面我们依次讲解。</p>
<h4 id="WorkQueue-tryRemoveAndExec-ForkJoinTask-lt-gt-task"><a href="#WorkQueue-tryRemoveAndExec-ForkJoinTask-lt-gt-task" class="headerlink" title="WorkQueue.tryRemoveAndExec(ForkJoinTask&lt;?&gt; task)"></a>WorkQueue.tryRemoveAndExec(ForkJoinTask&lt;?&gt; task)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRemoveAndExec</span><span class="params">(ForkJoinTask&lt;?&gt; task)</span> &#123;</span><br><span class="line">    ForkJoinTask&lt;?&gt;[] a;</span><br><span class="line">    <span class="type">int</span> m, s, b, n;</span><br><span class="line">    <span class="keyword">if</span> ((a = array) != <span class="literal">null</span> &amp;&amp; (m = a.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            task != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((n = (s = top) - (b = base)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//从top往下自旋查找</span></span><br><span class="line">            <span class="keyword">for</span> (ForkJoinTask&lt;?&gt; t; ; ) &#123;      <span class="comment">// traverse from s to b</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">j</span> <span class="operator">=</span> ((--s &amp; m) &lt;&lt; ASHIFT) + ABASE;<span class="comment">//计算任务索引</span></span><br><span class="line">                <span class="keyword">if</span> ((t = (ForkJoinTask&lt;?&gt;) U.getObject(a, j)) == <span class="literal">null</span>) <span class="comment">//获取索引到的任务</span></span><br><span class="line">                    <span class="keyword">return</span> s + <span class="number">1</span> == top;     <span class="comment">// shorter than expected</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (t == task) &#123; <span class="comment">//给定任务为索引任务</span></span><br><span class="line">                    <span class="type">boolean</span> <span class="variable">removed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (s + <span class="number">1</span> == top) &#123;      <span class="comment">// pop</span></span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapObject(a, j, task, <span class="literal">null</span>)) &#123; <span class="comment">//弹出任务</span></span><br><span class="line">                            U.putOrderedInt(<span class="built_in">this</span>, QTOP, s); <span class="comment">//更新top</span></span><br><span class="line">                            removed = <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (base == b)      <span class="comment">// replace with proxy</span></span><br><span class="line">                        removed = U.compareAndSwapObject(</span><br><span class="line">                                a, j, task, <span class="keyword">new</span> <span class="title class_">EmptyTask</span>()); <span class="comment">//join任务已经被移除，替换为一个占位任务</span></span><br><span class="line">                    <span class="keyword">if</span> (removed)</span><br><span class="line">                        task.doExec(); <span class="comment">//执行</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (t.status &lt; <span class="number">0</span> &amp;&amp; s + <span class="number">1</span> == top) &#123; <span class="comment">//给定任务不是top任务</span></span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapObject(a, j, t, <span class="literal">null</span>)) <span class="comment">//弹出任务</span></span><br><span class="line">                        U.putOrderedInt(<span class="built_in">this</span>, QTOP, s);<span class="comment">//更新top</span></span><br><span class="line">                    <span class="keyword">break</span>;                  <span class="comment">// was cancelled</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (--n == <span class="number">0</span>) <span class="comment">//遍历结束</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (task.status &lt; <span class="number">0</span>) <span class="comment">//任务执行完毕</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: 从top位开始自旋向下找到给定任务，如果找到把它从当前 Worker 的任务队列中移除并执行它。注意返回的参数: 如果任务队列为空或者任务未执行完毕返回true；任务执行完毕返回false。</p>
<h4 id="ForkJoinPool-helpStealer-WorkQueue-w-ForkJoinTask-lt-gt-task"><a href="#ForkJoinPool-helpStealer-WorkQueue-w-ForkJoinTask-lt-gt-task" class="headerlink" title="ForkJoinPool.helpStealer(WorkQueue w, ForkJoinTask&lt;?&gt; task)"></a>ForkJoinPool.helpStealer(WorkQueue w, ForkJoinTask&lt;?&gt; task)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helpStealer</span><span class="params">(WorkQueue w, ForkJoinTask&lt;?&gt; task)</span> &#123;</span><br><span class="line">    WorkQueue[] ws = workQueues;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldSum</span> <span class="operator">=</span> <span class="number">0</span>, checkSum, m;</span><br><span class="line">    <span class="keyword">if</span> (ws != <span class="literal">null</span> &amp;&amp; (m = ws.length - <span class="number">1</span>) &gt;= <span class="number">0</span> &amp;&amp; w != <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            task != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;                                       <span class="comment">// restart point</span></span><br><span class="line">            checkSum = <span class="number">0</span>;                          <span class="comment">// for stability check</span></span><br><span class="line">            ForkJoinTask&lt;?&gt; subtask;</span><br><span class="line">            <span class="type">WorkQueue</span> <span class="variable">j</span> <span class="operator">=</span> w, v;                    <span class="comment">// v is subtask stealer</span></span><br><span class="line">            descent:</span><br><span class="line">            <span class="keyword">for</span> (subtask = task; subtask.status &gt;= <span class="number">0</span>; ) &#123;</span><br><span class="line">                <span class="comment">//1. 找到给定WorkQueue的偷取者v</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> j.hint | <span class="number">1</span>, k = <span class="number">0</span>, i; ; k += <span class="number">2</span>) &#123;<span class="comment">//跳两个索引，因为Worker在奇数索引位</span></span><br><span class="line">                    <span class="keyword">if</span> (k &gt; m)                     <span class="comment">// can&#x27;t find stealer</span></span><br><span class="line">                        <span class="keyword">break</span> descent;</span><br><span class="line">                    <span class="keyword">if</span> ((v = ws[i = (h + k) &amp; m]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (v.currentSteal == subtask) &#123;<span class="comment">//定位到偷取者</span></span><br><span class="line">                            j.hint = i;<span class="comment">//更新stealer索引</span></span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        checkSum += v.base;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//2. 帮助偷取者v执行任务</span></span><br><span class="line">                <span class="keyword">for</span> (; ; ) &#123;                         <span class="comment">// help v or descend</span></span><br><span class="line">                    ForkJoinTask&lt;?&gt;[] a;            <span class="comment">//偷取者内部的任务</span></span><br><span class="line">                    <span class="type">int</span> b;</span><br><span class="line">                    checkSum += (b = v.base);</span><br><span class="line">                    ForkJoinTask&lt;?&gt; next = v.currentJoin;<span class="comment">//获取偷取者的join任务</span></span><br><span class="line">                    <span class="keyword">if</span> (subtask.status &lt; <span class="number">0</span> || j.currentJoin != subtask ||</span><br><span class="line">                            v.currentSteal != subtask) <span class="comment">// stale</span></span><br><span class="line">                        <span class="keyword">break</span> descent; <span class="comment">// stale，跳出descent循环重来</span></span><br><span class="line">                    <span class="keyword">if</span> (b - v.top &gt;= <span class="number">0</span> || (a = v.array) == <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((subtask = next) == <span class="literal">null</span>)   <span class="comment">//偷取者的join任务为null，跳出descent循环</span></span><br><span class="line">                            <span class="keyword">break</span> descent;</span><br><span class="line">                        j = v;</span><br><span class="line">                        <span class="keyword">break</span>; <span class="comment">//偷取者内部任务为空，可能任务也被偷走了；跳出本次循环，查找偷取者的偷取者</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (((a.length - <span class="number">1</span>) &amp; b) &lt;&lt; ASHIFT) + ABASE;<span class="comment">//获取base偏移地址</span></span><br><span class="line">                    ForkJoinTask&lt;?&gt; t = ((ForkJoinTask&lt;?&gt;)</span><br><span class="line">                            U.getObjectVolatile(a, i));<span class="comment">//获取偷取者的base任务</span></span><br><span class="line">                    <span class="keyword">if</span> (v.base == b) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (t == <span class="literal">null</span>)             <span class="comment">// stale</span></span><br><span class="line">                            <span class="keyword">break</span> descent; <span class="comment">// stale，跳出descent循环重来</span></span><br><span class="line">                        <span class="keyword">if</span> (U.compareAndSwapObject(a, i, t, <span class="literal">null</span>)) &#123;<span class="comment">//弹出任务</span></span><br><span class="line">                            v.base = b + <span class="number">1</span>;         <span class="comment">//更新偷取者的base位</span></span><br><span class="line">                            ForkJoinTask&lt;?&gt; ps = w.currentSteal;<span class="comment">//获取调用者偷来的任务</span></span><br><span class="line">                            <span class="type">int</span> <span class="variable">top</span> <span class="operator">=</span> w.top;</span><br><span class="line">                            <span class="comment">//首先更新给定workQueue的currentSteal为偷取者的base任务，然后执行该任务</span></span><br><span class="line">                            <span class="comment">//然后通过检查top来判断给定workQueue是否有自己的任务，如果有，</span></span><br><span class="line">                            <span class="comment">// 则依次弹出任务(LIFO)-&gt;更新currentSteal-&gt;执行该任务(注意这里是自己偷自己的任务执行)</span></span><br><span class="line">                            <span class="keyword">do</span> &#123;</span><br><span class="line">                                U.putOrderedObject(w, QCURRENTSTEAL, t);</span><br><span class="line">                                t.doExec();        <span class="comment">// clear local tasks too</span></span><br><span class="line">                            &#125; <span class="keyword">while</span> (task.status &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                    w.top != top &amp;&amp; <span class="comment">//内部有自己的任务，依次弹出执行</span></span><br><span class="line">                                    (t = w.pop()) != <span class="literal">null</span>);</span><br><span class="line">                            U.putOrderedObject(w, QCURRENTSTEAL, ps);<span class="comment">//还原给定workQueue的currentSteal</span></span><br><span class="line">                            <span class="keyword">if</span> (w.base != w.top)<span class="comment">//给定workQueue有自己的任务了，帮助结束，返回</span></span><br><span class="line">                                <span class="keyword">return</span>;            <span class="comment">// can&#x27;t further help</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (task.status &gt;= <span class="number">0</span> &amp;&amp; oldSum != (oldSum = checkSum));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: 如果队列为空或任务执行失败，说明任务可能被偷，调用此方法来帮助偷取者执行任务。基本思想是: 偷取者帮助我执行任务，我去帮助偷取者执行它的任务。 函数执行流程如下:</p>
<p>循环定位偷取者，由于Worker是在奇数索引位，所以每次会跳两个索引位。定位到偷取者之后，更新调用者 WorkQueue 的hint为偷取者的索引，方便下次定位； 定位到偷取者后，开始帮助偷取者执行任务。从偷取者的base索引开始，每次偷取一个任务执行。在帮助偷取者执行任务后，如果调用者发现本身已经有任务(w.top !&#x3D; top)，则依次弹出自己的任务(LIFO顺序)并执行(也就是说自己偷自己的任务执行)。</p>
<h4 id="ForkJoinPool-tryCompensate-WorkQueue-w"><a href="#ForkJoinPool-tryCompensate-WorkQueue-w" class="headerlink" title="ForkJoinPool.tryCompensate(WorkQueue w)"></a>ForkJoinPool.tryCompensate(WorkQueue w)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//执行补偿操作: 尝试缩减活动线程量，可能释放或创建一个补偿线程来准备阻塞</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">tryCompensate</span><span class="params">(WorkQueue w)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> canBlock;</span><br><span class="line">    WorkQueue[] ws;</span><br><span class="line">    <span class="type">long</span> c;</span><br><span class="line">    <span class="type">int</span> m, pc, sp;</span><br><span class="line">    <span class="keyword">if</span> (w == <span class="literal">null</span> || w.qlock &lt; <span class="number">0</span> ||           <span class="comment">// caller terminating</span></span><br><span class="line">            (ws = workQueues) == <span class="literal">null</span> || (m = ws.length - <span class="number">1</span>) &lt;= <span class="number">0</span> ||</span><br><span class="line">            (pc = config &amp; SMASK) == <span class="number">0</span>)           <span class="comment">// parallelism disabled</span></span><br><span class="line">        canBlock = <span class="literal">false</span>; <span class="comment">//调用者已终止</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((sp = (<span class="type">int</span>) (c = ctl)) != <span class="number">0</span>)      <span class="comment">// release idle worker</span></span><br><span class="line">        canBlock = tryRelease(c, ws[sp &amp; m], <span class="number">0L</span>);<span class="comment">//唤醒等待的工作线程</span></span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">//没有空闲线程</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ac</span> <span class="operator">=</span> (<span class="type">int</span>) (c &gt;&gt; AC_SHIFT) + pc; <span class="comment">//活跃线程数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tc</span> <span class="operator">=</span> (<span class="type">short</span>) (c &gt;&gt; TC_SHIFT) + pc;<span class="comment">//总线程数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nbusy</span> <span class="operator">=</span> <span class="number">0</span>;                        <span class="comment">// validate saturation</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; ++i) &#123;        <span class="comment">// two passes of odd indices</span></span><br><span class="line">            WorkQueue v;</span><br><span class="line">            <span class="keyword">if</span> ((v = ws[((i &lt;&lt; <span class="number">1</span>) | <span class="number">1</span>) &amp; m]) != <span class="literal">null</span>) &#123;<span class="comment">//取奇数索引位</span></span><br><span class="line">                <span class="keyword">if</span> ((v.scanState &amp; SCANNING) != <span class="number">0</span>)<span class="comment">//没有正在运行任务，跳出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ++nbusy;<span class="comment">//正在运行任务，添加标记</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nbusy != (tc &lt;&lt; <span class="number">1</span>) || ctl != c)</span><br><span class="line">            canBlock = <span class="literal">false</span>;                 <span class="comment">// unstable or stale</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tc &gt;= pc &amp;&amp; ac &gt; <span class="number">1</span> &amp;&amp; w.isEmpty()) &#123;<span class="comment">//总线程数大于并行度 &amp;&amp; 活动线程数大于1 &amp;&amp; 调用者任务队列为空，不需要补偿</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">nc</span> <span class="operator">=</span> ((AC_MASK &amp; (c - AC_UNIT)) |</span><br><span class="line">                    (~AC_MASK &amp; c));       <span class="comment">// uncompensated</span></span><br><span class="line">            canBlock = U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, nc);<span class="comment">//更新活跃线程数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tc &gt;= MAX_CAP ||</span><br><span class="line">                (<span class="built_in">this</span> == common &amp;&amp; tc &gt;= pc + commonMaxSpares))<span class="comment">//超出最大线程数</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(</span><br><span class="line">                    <span class="string">&quot;Thread limit exceeded replacing blocked worker&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;                                <span class="comment">// similar to tryAddWorker</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">add</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="type">int</span> rs;      <span class="comment">// CAS within lock</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">nc</span> <span class="operator">=</span> ((AC_MASK &amp; c) |</span><br><span class="line">                    (TC_MASK &amp; (c + TC_UNIT)));<span class="comment">//计算总线程数</span></span><br><span class="line">            <span class="keyword">if</span> (((rs = lockRunState()) &amp; STOP) == <span class="number">0</span>)</span><br><span class="line">                add = U.compareAndSwapLong(<span class="built_in">this</span>, CTL, c, nc);<span class="comment">//更新总线程数</span></span><br><span class="line">            unlockRunState(rs, rs &amp; ~RSLOCK);</span><br><span class="line">            <span class="comment">//运行到这里说明活跃工作线程数不足，需要创建一个新的工作线程来补偿</span></span><br><span class="line">            canBlock = add &amp;&amp; createWorker(); <span class="comment">// throws on exception</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> canBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明: 具体的执行看源码及注释，这里我们简单总结一下需要和不需要补偿的几种情况:</p>
<p><strong>需要补偿</strong> :</p>
<ul>
<li>调用者队列不为空，并且有空闲工作线程，这种情况会唤醒空闲线程(调用tryRelease方法)</li>
<li>池尚未停止，活跃线程数不足，这时会新建一个工作线程(调用createWorker方法)</li>
</ul>
<p><strong>不需要补偿</strong> :</p>
<ul>
<li>调用者已终止或池处于不稳定状态</li>
<li>总线程数大于并行度 &amp;&amp; 活动线程数大于1 &amp;&amp; 调用者任务队列为空</li>
</ul>
<h2 id="Fork-x2F-Join的陷阱与注意事项"><a href="#Fork-x2F-Join的陷阱与注意事项" class="headerlink" title="Fork&#x2F;Join的陷阱与注意事项"></a>Fork&#x2F;Join的陷阱与注意事项</h2><p>使用Fork&#x2F;Join框架时，需要注意一些陷阱, 在下面 <code>斐波那契数列</code>例子中你将看到示例:</p>
<h3 id="避免不必要的fork"><a href="#避免不必要的fork" class="headerlink" title="避免不必要的fork()"></a>避免不必要的fork()</h3><p>划分成两个子任务后，不要同时调用两个子任务的fork()方法。</p>
<p>表面上看上去两个子任务都fork()，然后join()两次似乎更自然。但事实证明，直接调用compute()效率更高。因为直接调用子任务的compute()方法实际上就是在当前的工作线程进行了计算(线程重用)，这比“将子任务提交到工作队列，线程又从工作队列中拿任务”快得多。</p>
<blockquote>
<p>当一个大任务被划分成两个以上的子任务时，尽可能使用前面说到的三个衍生的invokeAll方法，因为使用它们能避免不必要的fork()。</p>
</blockquote>
<h3 id="注意fork-、compute-、join-的顺序"><a href="#注意fork-、compute-、join-的顺序" class="headerlink" title="注意fork()、compute()、join()的顺序"></a>注意fork()、compute()、join()的顺序</h3><p>为了两个任务并行，三个方法的调用顺序需要万分注意。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">right.fork(); <span class="comment">// 计算右边的任务</span></span><br><span class="line"><span class="type">long</span> <span class="variable">leftAns</span> <span class="operator">=</span> left.compute(); <span class="comment">// 计算左边的任务(同时右边任务也在计算)</span></span><br><span class="line"><span class="type">long</span> <span class="variable">rightAns</span> <span class="operator">=</span> right.join(); <span class="comment">// 等待右边的结果</span></span><br><span class="line"><span class="keyword">return</span> leftAns + rightAns;</span><br></pre></td></tr></table></figure>

<p>如果我们写成:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">left.fork(); <span class="comment">// 计算完左边的任务</span></span><br><span class="line"><span class="type">long</span> <span class="variable">leftAns</span> <span class="operator">=</span> left.join(); <span class="comment">// 等待左边的计算结果</span></span><br><span class="line"><span class="type">long</span> <span class="variable">rightAns</span> <span class="operator">=</span> right.compute(); <span class="comment">// 再计算右边的任务</span></span><br><span class="line"><span class="keyword">return</span> leftAns + rightAns;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">rightAns</span> <span class="operator">=</span> right.compute(); <span class="comment">// 计算完右边的任务</span></span><br><span class="line">left.fork(); <span class="comment">// 再计算左边的任务</span></span><br><span class="line"><span class="type">long</span> <span class="variable">leftAns</span> <span class="operator">=</span> left.join(); <span class="comment">// 等待左边的计算结果</span></span><br><span class="line"><span class="keyword">return</span> leftAns + rightAns;</span><br></pre></td></tr></table></figure>

<p>这两种实际上都没有并行。</p>
<h3 id="选择合适的子任务粒度"><a href="#选择合适的子任务粒度" class="headerlink" title="选择合适的子任务粒度"></a>选择合适的子任务粒度</h3><p>选择划分子任务的粒度(顺序执行的阈值)很重要，因为使用Fork&#x2F;Join框架并不一定比顺序执行任务的效率高: 如果任务太大，则无法提高并行的吞吐量；如果任务太小，子任务的调度开销可能会大于并行计算的性能提升，我们还要考虑创建子任务、fork()子任务、线程调度以及合并子任务处理结果的耗时以及相应的内存消耗。</p>
<p>官方文档给出的粗略经验是: 任务应该执行<code>100~10000</code>个基本的计算步骤。决定子任务的粒度的最好办法是实践，通过实际测试结果来确定这个阈值才是“上上策”。</p>
<blockquote>
<p>和其他Java代码一样，Fork&#x2F;Join框架测试时需要“预热”或者说执行几遍才会被JIT(Just-in-time)编译器优化，所以测试性能之前跑几遍程序很重要。</p>
</blockquote>
<h3 id="避免重量级任务划分与结果合并"><a href="#避免重量级任务划分与结果合并" class="headerlink" title="避免重量级任务划分与结果合并"></a>避免重量级任务划分与结果合并</h3><p>Fork&#x2F;Join的很多使用场景都用到数组或者List等数据结构，子任务在某个分区中运行，最典型的例子如并行排序和并行查找。拆分子任务以及合并处理结果的时候，应该尽量避免System.arraycopy这样耗时耗空间的操作，从而最小化任务的处理开销。</p>
<h2 id="再深入理解"><a href="#再深入理解" class="headerlink" title="再深入理解"></a>再深入理解</h2><h3 id="有哪些JDK源码中使用了Fork-x2F-Join思想"><a href="#有哪些JDK源码中使用了Fork-x2F-Join思想" class="headerlink" title="有哪些JDK源码中使用了Fork&#x2F;Join思想?"></a>有哪些JDK源码中使用了Fork&#x2F;Join思想?</h3><p>我们常用的数组工具类 Arrays 在JDK 8之后新增的并行排序方法(parallelSort)就运用了 ForkJoinPool 的特性，还有 ConcurrentHashMap 在JDK 8之后添加的函数式方法(如forEach等)也有运用。</p>
<h3 id="使用Executors工具类创建ForkJoinPool"><a href="#使用Executors工具类创建ForkJoinPool" class="headerlink" title="使用Executors工具类创建ForkJoinPool"></a>使用Executors工具类创建ForkJoinPool</h3><p>Java8在Executors工具类中新增了两个工厂方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parallelism定义并行级别</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">(<span class="type">int</span> parallelism)</span>;</span><br><span class="line"><span class="comment">// 默认并行级别为JVM可用的处理器个数</span></span><br><span class="line"><span class="comment">// Runtime.getRuntime().availableProcessors()</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newWorkStealingPool</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<h3 id="关于Fork-x2F-Join异常处理"><a href="#关于Fork-x2F-Join异常处理" class="headerlink" title="关于Fork&#x2F;Join异常处理"></a>关于Fork&#x2F;Join异常处理</h3><p>Java的受检异常机制一直饱受诟病，所以在ForkJoinTask的invoke()、join()方法及其衍生方法中都没有像get()方法那样抛出个ExecutionException的受检异常。</p>
<p>所以你可以在ForkJoinTask中看到内部把受检异常转换成了运行时异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">rethrow</span><span class="params">(Throwable ex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="literal">null</span>)</span><br><span class="line">        ForkJoinTask.&lt;RuntimeException&gt;uncheckedThrow(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">static</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; <span class="keyword">void</span> <span class="title function_">uncheckedThrow</span><span class="params">(Throwable t)</span> <span class="keyword">throws</span> T &#123;</span><br><span class="line">    <span class="keyword">throw</span> (T)t; <span class="comment">// rely on vacuous cast</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于Java你不知道的10件事中已经指出，JVM实际并不关心这个异常是受检异常还是运行时异常，受检异常这东西完全是给Java编译器用的: 用于警告程序员这里有个异常没有处理。</p>
<p>但不可否认的是invoke、join()仍可能会抛出运行时异常，所以ForkJoinTask还提供了两个不提取结果和异常的方法quietlyInvoke()、quietlyJoin()，这两个方法允许你在所有任务完成后对结果和异常进行处理。</p>
<p>使用quitelyInvoke()和quietlyJoin()时可以配合isCompletedAbnormally()和isCompletedNormally()方法使用。</p>
<h2 id="一些Fork-x2F-Join例子"><a href="#一些Fork-x2F-Join例子" class="headerlink" title="一些Fork&#x2F;Join例子"></a>一些Fork&#x2F;Join例子</h2><h3 id="采用Fork-x2F-Join来异步计算1-2-3-…-10000的结果"><a href="#采用Fork-x2F-Join来异步计算1-2-3-…-10000的结果" class="headerlink" title="采用Fork&#x2F;Join来异步计算1+2+3+…+10000的结果"></a>采用Fork&#x2F;Join来异步计算1+2+3+…+10000的结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">SumTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">final</span> <span class="type">int</span> start; <span class="comment">//开始计算的数</span></span><br><span class="line">		<span class="keyword">final</span> <span class="type">int</span> end; <span class="comment">//最后计算的数</span></span><br><span class="line">		</span><br><span class="line">		SumTask(<span class="type">int</span> start, <span class="type">int</span> end) &#123;</span><br><span class="line">			<span class="built_in">this</span>.start = start;</span><br><span class="line">			<span class="built_in">this</span>.end = end;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">			<span class="comment">//如果计算量小于1000，那么分配一个线程执行if中的代码块，并返回执行结果</span></span><br><span class="line">			<span class="keyword">if</span>(end - start &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 开始执行: &quot;</span> + start + <span class="string">&quot;-&quot;</span> + end);</span><br><span class="line">				<span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= end; i++)</span><br><span class="line">					sum += i;</span><br><span class="line">				<span class="keyword">return</span> sum;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果计算量大于1000，那么拆分为两个任务</span></span><br><span class="line">			<span class="type">SumTask</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>(start, (start + end) / <span class="number">2</span>);</span><br><span class="line">			<span class="type">SumTask</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SumTask</span>((start + end) / <span class="number">2</span> + <span class="number">1</span>, end);</span><br><span class="line">			<span class="comment">//执行任务</span></span><br><span class="line">			task1.fork();</span><br><span class="line">			task2.fork();</span><br><span class="line">			<span class="comment">//获取任务执行的结果</span></span><br><span class="line">			<span class="keyword">return</span> task1.join() + task2.join();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">		<span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">		ForkJoinTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">SumTask</span>(<span class="number">1</span>, <span class="number">10000</span>);</span><br><span class="line">		pool.submit(task);</span><br><span class="line">		System.out.println(task.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>执行结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span> 开始执行: <span class="number">1</span>-<span class="number">625</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">7</span> 开始执行: <span class="number">6251</span>-<span class="number">6875</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">6</span> 开始执行: <span class="number">5626</span>-<span class="number">6250</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">10</span> 开始执行: <span class="number">3751</span>-<span class="number">4375</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">13</span> 开始执行: <span class="number">2501</span>-<span class="number">3125</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">8</span> 开始执行: <span class="number">626</span>-<span class="number">1250</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">11</span> 开始执行: <span class="number">5001</span>-<span class="number">5625</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">3</span> 开始执行: <span class="number">7501</span>-<span class="number">8125</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">14</span> 开始执行: <span class="number">1251</span>-<span class="number">1875</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">4</span> 开始执行: <span class="number">9376</span>-<span class="number">10000</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">8</span> 开始执行: <span class="number">8126</span>-<span class="number">8750</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">0</span> 开始执行: <span class="number">1876</span>-<span class="number">2500</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">12</span> 开始执行: <span class="number">4376</span>-<span class="number">5000</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">5</span> 开始执行: <span class="number">8751</span>-<span class="number">9375</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">7</span> 开始执行: <span class="number">6876</span>-<span class="number">7500</span></span><br><span class="line">ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span> 开始执行: <span class="number">3126</span>-<span class="number">3750</span></span><br><span class="line"><span class="number">50005000</span></span><br></pre></td></tr></table></figure>

<h3 id="实现斐波那契数列"><a href="#实现斐波那契数列" class="headerlink" title="实现斐波那契数列"></a>实现斐波那契数列</h3><blockquote>
<p>斐波那契数列: 1、1、2、3、5、8、13、21、34、…… 公式 : F(1)&#x3D;1，F(2)&#x3D;1, F(n)&#x3D;F(n-1)+F(n-2)(n&gt;&#x3D;3，n∈N*)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ForkJoinPool</span> <span class="variable">forkJoinPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>); <span class="comment">// 最大并发数4</span></span><br><span class="line">    <span class="type">Fibonacci</span> <span class="variable">fibonacci</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> forkJoinPool.invoke(fibonacci);</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;Fork/join sum: &quot;</span> + result + <span class="string">&quot; in &quot;</span> + (endTime - startTime) + <span class="string">&quot; ms.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下为官方API文档示例</span></span><br><span class="line"><span class="keyword">static</span>  <span class="keyword">class</span> <span class="title class_">Fibonacci</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> n;</span><br><span class="line">    Fibonacci(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Fibonacci</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(n - <span class="number">1</span>);</span><br><span class="line">        f1.fork(); </span><br><span class="line">        <span class="type">Fibonacci</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> f2.compute() + f1.join(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然你也可以两个任务都fork，要注意的是两个任务都fork的情况，必须按照f1.fork()，f2.fork()， f2.join()，f1.join()这样的顺序，不然有性能问题，详见上面注意事项中的说明。</p>
<p>官方API文档是这样写到的，所以平日用invokeAll就好了。invokeAll会把传入的任务的第一个交给当前线程来执行，其他的任务都fork加入工作队列，这样等于利用当前线程也执行任务了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="type">Fibonacci</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(n - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Fibonacci</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">    invokeAll(f1,f2);</span><br><span class="line">    <span class="keyword">return</span> f2.join() + f1.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeAll</span><span class="params">(ForkJoinTask&lt;?&gt;... tasks)</span> &#123;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> tasks.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> last; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; t = tasks[i];</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ex == <span class="literal">null</span>)</span><br><span class="line">                ex = <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span>)   <span class="comment">//除了第一个都fork</span></span><br><span class="line">            t.fork();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (t.doInvoke() &lt; NORMAL &amp;&amp; ex == <span class="literal">null</span>)  <span class="comment">//留一个自己执行</span></span><br><span class="line">            ex = t.getException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= last; ++i) &#123;</span><br><span class="line">        ForkJoinTask&lt;?&gt; t = tasks[i];</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ex != <span class="literal">null</span>)</span><br><span class="line">                t.cancel(<span class="literal">false</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (t.doJoin() &lt; NORMAL)</span><br><span class="line">                ex = t.getException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ex != <span class="literal">null</span>)</span><br><span class="line">        rethrow(ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li>首先推荐阅读ForkJoinPool的作者Doug Lea的一篇文章《A Java Fork&#x2F;Join Framework》<a target="_blank" rel="noopener" href="http://gee.cs.oswego.edu/dl/papers/fj.pdf">英文原文地址在新窗口打开</a></li>
<li>本文主要参考自泰迪的bagwell的<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/32a15ef2f1bf%E5%92%8Chttps://www.jianshu.com/p/6a14d0b54b8d%EF%BC%8C%E5%9C%A8%E6%AD%A4%E5%9F%BA%E7%A1%80%E4%B8%8A%E5%8F%82%E8%80%83%E4%BA%86%E5%A6%82%E4%B8%8B%E6%96%87%E7%AB%A0">https://www.jianshu.com/p/32a15ef2f1bf和https://www.jianshu.com/p/6a14d0b54b8d，在此基础上参考了如下文章</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010841296/article/details/83963637">https://blog.csdn.net/u010841296/article/details/83963637</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/Holmofy/article/details/82714665">https://blog.csdn.net/Holmofy/article/details/82714665</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/abc123lzf/article/details/82873181">https://blog.csdn.net/abc123lzf/article/details/82873181</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/yinwenjie/article/details/71524140">https://blog.csdn.net/yinwenjie/article/details/71524140</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/cowbin2012/article/details/89791757">https://blog.csdn.net/cowbin2012/article/details/89791757</a></li>
</ul>

      
       <hr><span style="font-style: italic;color: gray;"> 转载请注明来源，欢迎对文章中的引用来源进行考证，欢迎指出任何有错误或不够清晰的表达。可以在下面评论区评论，也可以邮件至 w_huilong@163.com </span>
    </div>
</article>







    




    </div>
    <div class="copyright">
        <p class="footer-entry">
    ©2017 王云生
</p>
<p class="footer-entry">Built with <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/yelog/hexo-theme-3-hexo" target="_blank">3-hexo</a> theme</p>

    </div>
    <div class="full-toc">
        <button class="full" data-title="切换全屏 快捷键 s"><span class="min "></span></button>
<a class="" id="rocket" ></a>

    </div>
</div>

</body>
<script src="/js/jquery.pjax.js?v=1.1.0" ></script>

<script src="/js/script.js?v=1.1.0" ></script>
<script>
    var img_resize = 'default';
    function initArticle() {
        /*渲染对应的表格样式*/
        
            $("#post .pjax table").addClass("green_title");
        

        /*渲染打赏样式*/
        

        /*高亮代码块行号*/
        

        /*访问数量*/
        
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js");
        

        /*代码高亮，行号对齐*/
        $('.pre-numbering').css('line-height',$('.has-numbering').css('line-height'));

        
        
    }

    /*打赏页面隐藏与展示*/
    

</script>

<!--加入行号的高亮代码块样式-->

<!--自定义样式设置-->
<style>
    
    
    .nav {
        width: 542px;
    }
    .nav.fullscreen {
        margin-left: -542px;
    }
    .nav-left {
        width: 120px;
    }
    
    
    @media screen and (max-width: 1468px) {
        .nav {
            width: 492px;
        }
        .nav.fullscreen {
            margin-left: -492px;
        }
        .nav-left {
            width: 100px;
        }
    }
    
    
    @media screen and (max-width: 1024px) {
        .nav {
            width: 492px;
            margin-left: -492px
        }
        .nav.fullscreen {
            margin-left: 0;
        }
    }
    
    @media screen and (max-width: 426px) {
        .nav {
            width: 100%;
        }
        .nav-left {
            width: 100%;
        }
    }
    
    
    .nav-right .title-list nav a .post-title, .nav-right .title-list #local-search-result a .post-title {
        color: #383636;
    }
    
    
    .nav-right .title-list nav a .post-date, .nav-right .title-list #local-search-result a .post-date {
        color: #5e5e5f;
    }
    
    
    .nav-right nav a.hover, #local-search-result a.hover{
        background-color: #e2e0e0;
    }
    
    

    /*列表样式*/
    

    /* 背景图样式 */
    
    


    /*引用块样式*/
    

    /*文章列表背景图*/
    

    
</style>







</html>
